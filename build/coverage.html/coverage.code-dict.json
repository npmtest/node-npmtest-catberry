{"/home/travis/build/npmtest/node-npmtest-catberry/test.js":"/* istanbul instrument in package npmtest_catberry */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-catberry/lib.npmtest_catberry.js":"/* istanbul instrument in package npmtest_catberry */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_catberry = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_catberry = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-catberry/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-catberry && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_catberry */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_catberry\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_catberry.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_catberry.rollup.js'] =\n            local.assetsDict['/assets.npmtest_catberry.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_catberry.__dirname +\n                    '/lib.npmtest_catberry.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/index.js":"'use strict';\n\nmodule.exports = require('./lib/Bootstrapper');\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/Bootstrapper.js":"'use strict';\n\nconst path = require('path');\nconst StoreDispatcher = require('./StoreDispatcher');\nconst ModuleApiProvider = require('./providers/ModuleApiProvider');\nconst CookieWrapper = require('./CookieWrapper');\nconst BrowserBundleBuilder = require('./builders/BrowserBundleBuilder');\nconst AppDefinitionsBuilder = require('./builders/AppDefinitionsBuilder');\nconst StoreFinder = require('./finders/StoreFinder');\nconst ComponentFinder = require('./finders/ComponentFinder');\nconst BootstrapperBase = require('./base/BootstrapperBase');\nconst Catberry = require('./Catberry');\n\nvar routeDefinitions;\n// try to load list of URI mappers\ntry {\n\trouteDefinitions = require(path.join(process.cwd(), 'routes'));\n} catch (e) {\n\t// nothing to do here\n}\nrouteDefinitions = routeDefinitions || [];\n\nclass Bootstrapper extends BootstrapperBase {\n\n\t/**\n\t * Creates a new instance of the server-side Catberry's bootstrapper.\n\t */\n\tconstructor() {\n\t\tsuper(Catberry);\n\t}\n\n\t/**\n\t * Configures a Catberry's locator.\n\t * @param {Object} configObject Config object.\n\t * @param {ServiceLocator} locator Service locator to configure.\n\t */\n\tconfigure(configObject, locator) {\n\t\tsuper.configure(configObject, locator);\n\n\t\tlocator.register('storeDispatcher', StoreDispatcher);\n\t\tlocator.register('moduleApiProvider', ModuleApiProvider);\n\t\tlocator.register('cookieWrapper', CookieWrapper);\n\n\t\tlocator.register('browserBundleBuilder', BrowserBundleBuilder, true);\n\t\tlocator.register('appDefinitionsBuilder', AppDefinitionsBuilder, true);\n\t\tlocator.register('storeFinder', StoreFinder, true);\n\t\tlocator.register('componentFinder', ComponentFinder, true);\n\n\t\trouteDefinitions.forEach(routeDefinition =>\n\t\t\tlocator.registerInstance('routeDefinition', routeDefinition)\n\t\t);\n\t}\n}\n\nmodule.exports = new Bootstrapper();\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/StoreDispatcher.js":"'use strict';\n\nconst SerialWrapper = require('./SerialWrapper');\nconst moduleHelper = require('./helpers/moduleHelper');\nconst propertyHelper = require('./helpers/propertyHelper');\n\nconst DEFAULT_LIFETIME = 60000;\n\nclass StoreDispatcher {\n\n\t/**\n\t * Creates a new instance of the store dispatcher.\n\t * @param {ServiceLocator} locator Locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\n\t\t/**\n\t\t * Current service locator.\n\t\t * @type {ServiceLocator}\n\t\t * @private\n\t\t */\n\t\tthis._serviceLocator = locator;\n\n\t\t/**\n\t\t * Current store loader.\n\t\t * @type {StoreLoader}\n\t\t * @private\n\t\t */\n\t\tthis._storeLoader = locator.resolve('storeLoader');\n\n\t\t/**\n\t\t * Current event bus.\n\t\t * @type {EventEmitter}\n\t\t * @private\n\t\t */\n\t\tthis._eventBus = locator.resolve('eventBus');\n\n\t\t/**\n\t\t * Current map of all store instances.\n\t\t * @type {null}\n\t\t * @private\n\t\t */\n\t\tthis._storeInstances = Object.create(null);\n\n\t\t/**\n\t\t * Current map of last data for each store.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._lastData = Object.create(null);\n\n\t\t/**\n\t\t * Current map of last state of store dispatcher.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._lastState = null;\n\n\t\t/**\n\t\t * Current set of store dependency graph.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._dependants = Object.create(null);\n\n\t\t/**\n\t\t * Current serial wrapper.\n\t\t * @type {SerialWrapper}\n\t\t * @private\n\t\t */\n\t\tthis._serialWrapper = new SerialWrapper();\n\n\t\t/**\n\t\t * Current basic context for all store contexts.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._currentBasicContext = null;\n\t}\n\n\t/**\n\t * Gets store data and creates a store instance if required.\n\t * @param {string} storeName Name of store.\n\t * @returns {Object} Store's data.\n\t */\n\tgetStoreData(storeName) {\n\t\tif (!this._lastState) {\n\t\t\treturn this._errorState();\n\t\t}\n\t\tif (typeof (storeName) !== 'string') {\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\t\tif (storeName in this._lastData) {\n\t\t\tconst existTime = Date.now() - this._lastData[storeName].createdAt;\n\t\t\tif (existTime <= this._lastData[storeName].lifetime) {\n\t\t\t\treturn Promise.resolve(this._lastData[storeName].data);\n\t\t\t}\n\t\t\tdelete this._lastData[storeName];\n\t\t}\n\t\tthis._eventBus.emit('storeDataLoad', {\n\t\t\tname: storeName\n\t\t});\n\n\t\tconst store = this.getStore(storeName);\n\t\tif (!store) {\n\t\t\treturn this._errorStoreNotFound(storeName);\n\t\t}\n\n\t\tconst lifetime = typeof (store.$lifetime) === 'number' ?\n\t\t\tstore.$lifetime :\n\t\t\tDEFAULT_LIFETIME;\n\n\t\treturn this._serialWrapper.invoke(storeName)\n\t\t\t.then(data => {\n\t\t\t\tthis._lastData[storeName] = {\n\t\t\t\t\tdata,\n\t\t\t\t\tlifetime,\n\t\t\t\t\tcreatedAt: Date.now()\n\t\t\t\t};\n\t\t\t\tthis._eventBus.emit('storeDataLoaded', {\n\t\t\t\t\tname: storeName,\n\t\t\t\t\tdata,\n\t\t\t\t\tlifetime\n\t\t\t\t});\n\t\t\t\treturn data;\n\t\t\t});\n\t}\n\n\t/**\n\t * Sends an action to the specified store and resolves promises in the serial mode.\n\t * @param {string} storeName Name of the store.\n\t * @param {string} actionName Name of the action.\n\t * @param {Object} args Action arguments.\n\t * @returns {Promise<*>} Promise for an action handling result.\n\t */\n\tsendAction(storeName, actionName, args) {\n\t\tif (!this._lastState) {\n\t\t\treturn this._errorState();\n\t\t}\n\t\tconst actionDetails = {\n\t\t\tstoreName,\n\t\t\tactionName,\n\t\t\targs\n\t\t};\n\t\tthis._eventBus.emit('actionSend', actionDetails);\n\n\t\tconst store = this.getStore(storeName);\n\t\tif (!store) {\n\t\t\treturn this._errorStoreNotFound(storeName);\n\t\t}\n\n\t\tconst handleMethod = moduleHelper.getMethodToInvoke(\n\t\t\tstore, 'handle', actionName\n\t\t);\n\t\treturn moduleHelper.getSafePromise(() => handleMethod(args))\n\t\t\t.then(result => {\n\t\t\t\tthis._eventBus.emit('actionSent', actionDetails);\n\t\t\t\treturn result;\n\t\t\t});\n\t}\n\n\t/**\n\t * Sets a new state to the store dispatcher and invokes the \"changed\" method for all\n\t * stores which state has been changed.\n\t * @param {Object} parameters Map of new parameters.\n\t * @param {Object} basicContext Basic context for all stores.\n\t * @returns {Array<string>} Names of stores that have been changed.\n\t */\n\tsetState(parameters, basicContext) {\n\t\tparameters = parameters || Object.create(null);\n\n\t\tconst stores = this._storeLoader.getStoresByNames();\n\t\tconst parameterNames = Object.keys(parameters);\n\t\tparameterNames.forEach(storeName => {\n\t\t\tif (!(storeName in stores)) {\n\t\t\t\tthis._eventBus.emit('warn', `Store \"${storeName}\" does not exist (might be a typo in a route)`);\n\t\t\t}\n\t\t});\n\n\t\tif (!this._lastState) {\n\t\t\tthis._currentBasicContext = basicContext;\n\t\t\tthis._lastState = parameters;\n\t\t\treturn [];\n\t\t}\n\n\t\t// some store's parameters can be removed since last time\n\t\tconst changed = Object.create(null);\n\n\t\tObject.keys(this._lastState)\n\t\t\t.filter(storeName => !(storeName in parameters))\n\t\t\t.forEach(name => {\n\t\t\t\tchanged[name] = true;\n\t\t\t});\n\n\t\tparameterNames\n\t\t\t.forEach(storeName => {\n\t\t\t\t// new parameters were set for store\n\t\t\t\tif (!(storeName in this._lastState)) {\n\t\t\t\t\tchanged[storeName] = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// new and last parameters has different values\n\t\t\t\tconst lastParameterNames = Object.keys(this._lastState[storeName]);\n\t\t\t\tconst currentParameterNames = Object.keys(parameters[storeName]);\n\n\t\t\t\tif (currentParameterNames.length !== lastParameterNames.length) {\n\t\t\t\t\tchanged[storeName] = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcurrentParameterNames.every(parameterName => {\n\t\t\t\t\tif (parameters[storeName][parameterName] !==\n\t\t\t\t\t\tthis._lastState[storeName][parameterName]) {\n\t\t\t\t\t\tchanged[storeName] = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t});\n\n\t\tthis._lastState = parameters;\n\t\tif (this._currentBasicContext !== basicContext) {\n\t\t\tthis._currentBasicContext = basicContext;\n\t\t\tObject.keys(this._storeInstances)\n\t\t\t\t.forEach(storeName => {\n\t\t\t\t\tthis._storeInstances[storeName].$context = this._getStoreContext(storeName);\n\t\t\t\t});\n\t\t}\n\n\t\tconst changedStoreNames = Object.create(null);\n\t\tObject.keys(changed)\n\t\t\t.forEach(storeName => {\n\t\t\t\tconst store = this.getStore(storeName);\n\t\t\t\tif (!store) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tstore.$context.changed()\n\t\t\t\t\t.forEach(name => {\n\t\t\t\t\t\tchangedStoreNames[name] = true;\n\t\t\t\t\t});\n\t\t\t});\n\n\t\tthis._eventBus.emit('stateChanged', {\n\t\t\toldState: this._lastState,\n\t\t\tnewState: parameters\n\t\t});\n\t\treturn Object.keys(changedStoreNames);\n\t}\n\n\t/**\n\t * Gets a context for a store using component's context as a prototype.\n\t * @param {string} storeName Name of the store.\n\t * @returns {Object} Store context.\n\t * @private\n\t */\n\t_getStoreContext(storeName) {\n\t\tconst storeContext = Object.create(this._currentBasicContext);\n\t\tpropertyHelper.defineReadOnly(storeContext, 'name', storeName);\n\t\tpropertyHelper.defineReadOnly(\n\t\t\tstoreContext, 'state', this._lastState[storeName] || Object.create(null)\n\t\t);\n\n\t\tstoreContext.changed = () => {\n\t\t\tconst walked = Object.create(null);\n\t\t\tvar toChange = [storeName];\n\n\t\t\twhile (toChange.length > 0) {\n\t\t\t\tconst current = toChange.shift();\n\t\t\t\tif (current in walked) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twalked[current] = true;\n\t\t\t\tif (current in this._dependants) {\n\t\t\t\t\ttoChange = toChange.concat(Object.keys(this._dependants[current]));\n\t\t\t\t}\n\t\t\t\tdelete this._lastData[current];\n\t\t\t\tthis._eventBus.emit('storeChanged', current);\n\t\t\t}\n\t\t\treturn Object.keys(walked);\n\t\t};\n\n\t\tstoreContext.getStoreData = sourceStoreName => sourceStoreName === storeName ?\n\t\t\tPromise.resolve(null) :\n\t\t\tthis.getStoreData(sourceStoreName);\n\n\t\tstoreContext.setDependency = name => {\n\t\t\tif (!(name in this._dependants)) {\n\t\t\t\tthis._dependants[name] = Object.create(null);\n\t\t\t}\n\t\t\tthis._dependants[name][storeName] = true;\n\t\t};\n\t\tstoreContext.unsetDependency = name => {\n\t\t\tif (!(name in this._dependants)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdelete this._dependants[name][storeName];\n\t\t};\n\t\tstoreContext.sendAction = (storeName, name, args) => this.sendAction(storeName, name, args);\n\n\t\treturn storeContext;\n\t}\n\n\t/**\n\t * Gets a store instance and creates it if required.\n\t * @param {string} storeName Name of the store.\n\t * @returns {Promise<Object>} Promise for the store.\n\t */\n\tgetStore(storeName) {\n\t\tif (!storeName) {\n\t\t\treturn null;\n\t\t}\n\t\tconst store = this._storeInstances[storeName];\n\t\tif (store) {\n\t\t\treturn store;\n\t\t}\n\n\t\tconst stores = this._storeLoader.getStoresByNames();\n\t\tconst config = this._serviceLocator.resolve('config');\n\t\tif (!(storeName in stores)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst ComponentConstructor = stores[storeName].constructor;\n\t\tComponentConstructor.prototype.$context = this._getStoreContext(storeName);\n\t\tthis._storeInstances[storeName] = new ComponentConstructor(this._serviceLocator);\n\t\tthis._storeInstances[storeName].$context = ComponentConstructor.prototype.$context;\n\n\t\tthis._serialWrapper.add(storeName, () => {\n\t\t\tconst loadMethod = moduleHelper.getMethodToInvoke(\n\t\t\t\tthis._storeInstances[storeName], 'load'\n\t\t\t);\n\t\t\treturn moduleHelper.getSafePromise(loadMethod);\n\t\t});\n\t\treturn this._storeInstances[storeName];\n\t}\n\n\t/**\n\t * Returns an error message about a not found store.\n\t * @param  {string} name The store name.\n\t * @return {Promise<Error>} The promise for the error.\n\t */\n\t_errorStoreNotFound(name) {\n\t\treturn Promise.reject(new Error(`Store \"${name}\" not found`));\n\t}\n\n\t/**\n\t * Returns an error message about an uninitialized state.\n\t * @return {Promise<Error>} The promise for the error.\n\t */\n\t_errorState() {\n\t\treturn Promise.reject(new Error('State should be set before any request'));\n\t}\n}\n\nmodule.exports = StoreDispatcher;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/SerialWrapper.js":"'use strict';\n\nconst events = require('events');\n\nclass SerialWrapper {\n\n\t/**\n\t * Creates a new instance of the serial wrapper for promises.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * Current event emitter.\n\t\t * @type {EventEmitter}\n\t\t * @private\n\t\t */\n\t\tthis._emitter = new events.EventEmitter();\n\t\tthis._emitter.setMaxListeners(0);\n\n\t\t/**\n\t\t * Current set of named methods to invoke.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._toInvoke = Object.create(null);\n\n\t\t/**\n\t\t * Current set of flags if the method is in progress.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._inProgress = Object.create(null);\n\t}\n\n\t/**\n\t * Adds a method to the set.\n\t * @param {string} name Method name.\n\t * @param {Function} toInvoke Function that returns promise.\n\t */\n\tadd(name, toInvoke) {\n\t\tthis._toInvoke[name] = toInvoke;\n\t}\n\n\t/**\n\t * Returns true if the method with such name was registered to the set.\n\t * @param {string} name Name of method.\n\t * @returns {boolean} True if method name is registered.\n\t */\n\tisRegistered(name) {\n\t\treturn typeof (this._toInvoke[name]) === 'function';\n\t}\n\n\t/**\n\t * Invokes a method without concurrency.\n\t * @param {string} name Method name.\n\t * @returns {Promise<Object>} Promise for result.\n\t */\n\tinvoke(name) {\n\t\tif (!this.isRegistered(name)) {\n\t\t\treturn Promise.reject(new Error('There is no such registered method'));\n\t\t}\n\n\t\tif (this._inProgress[name]) {\n\t\t\treturn new Promise((fulfill, reject) => {\n\t\t\t\tthis._emitter.once(name, fulfill);\n\t\t\t\tthis._emitter.once(`${name}--error`, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis._inProgress[name] = true;\n\t\tthis._toInvoke[name]()\n\t\t\t.then(result => {\n\t\t\t\tthis._emitter.emit(name, result);\n\t\t\t\tthis._inProgress[name] = null;\n\t\t\t})\n\t\t\t.catch(reason => {\n\t\t\t\tthis._emitter.emit(`${name}--error`, reason);\n\t\t\t\tthis._inProgress[name] = null;\n\t\t\t});\n\n\t\treturn this.invoke(name);\n\t}\n}\n\nmodule.exports = SerialWrapper;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/helpers/moduleHelper.js":"'use strict';\n\nconst helper = {\n\tELEMENT_NODE_TYPE: 1,\n\tCOMPONENT_TAG_PREFIX: 'CAT-',\n\tCOMPONENT_ID: '$catberryId',\n\tCOMPONENT_PREFIX_REGEXP: /^cat-/i,\n\tCOMPONENT_ERROR_TEMPLATE_POSTFIX: '--error',\n\tDOCUMENT_COMPONENT_NAME: 'document',\n\tDOCUMENT_TAG_NAME: 'HTML',\n\tHEAD_TAG_NAME: 'HEAD',\n\tHEAD_COMPONENT_NAME: 'head',\n\tATTRIBUTE_STORE: 'cat-store',\n\tDEFAULT_LOGIC_FILENAME: 'index.js',\n\n\t/**\n\t * Creates a name for the error template of the component.\n\t * @param {string} componentName The name of the component.\n\t * @returns {string} The name of the error template of the component.\n\t */\n\tgetNameForErrorTemplate: componentName => {\n\t\tif (typeof (componentName) !== 'string') {\n\t\t\treturn '';\n\t\t}\n\t\treturn componentName + helper.COMPONENT_ERROR_TEMPLATE_POSTFIX;\n\t},\n\n\t/**\n\t * Determines if the specified component name is a \"document\" component's name.\n\t * @param {string} componentName The name of the component.\n\t * @returns {boolean} True if the specified component's name\n\t * is a \"document\" component's name.\n\t */\n\tisDocumentComponent: componentName =>\n\t\tcomponentName.toLowerCase() === helper.DOCUMENT_COMPONENT_NAME,\n\n\t/**\n\t * Determines if the specified component name is a \"head\" component name.\n\t * @param {string} componentName The name of the component.\n\t * @returns {boolean} True if the specified component's name\n\t * is a \"head\" component's name.\n\t */\n\tisHeadComponent: componentName =>\n\t\tcomponentName.toLowerCase() === helper.HEAD_COMPONENT_NAME,\n\n\t/**\n\t * Determines if the DOM node is a component element.\n\t * @param {Node} node The DOM node.\n\t */\n\tisComponentNode: node =>\n\t\tnode.nodeType === helper.ELEMENT_NODE_TYPE &&\n\t\t(\n\t\t\thelper.COMPONENT_PREFIX_REGEXP.test(node.nodeName) ||\n\t\t\tnode.nodeName === helper.HEAD_TAG_NAME ||\n\t\t\tnode.nodeName === helper.DOCUMENT_TAG_NAME\n\t\t),\n\n\t/**\n\t * Gets a original component's name without a prefix.\n\t * @param {string} fullComponentName The full component's name (tag name).\n\t * @returns {string} The original component's name without a prefix.\n\t */\n\tgetOriginalComponentName: fullComponentName => {\n\t\tif (typeof (fullComponentName) !== 'string') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (fullComponentName === helper.DOCUMENT_TAG_NAME) {\n\t\t\treturn helper.DOCUMENT_COMPONENT_NAME;\n\t\t}\n\n\t\tif (fullComponentName === helper.HEAD_TAG_NAME) {\n\t\t\treturn helper.HEAD_COMPONENT_NAME;\n\t\t}\n\n\t\treturn fullComponentName\n\t\t\t.toLowerCase()\n\t\t\t.replace(helper.COMPONENT_PREFIX_REGEXP, '');\n\t},\n\n\t/**\n\t * Gets a valid tag name for a component.\n\t * @param {string} componentName The name of the component.\n\t * @returns {string} The name of the tag.\n\t */\n\tgetTagNameForComponentName: componentName => {\n\t\tif (typeof (componentName) !== 'string') {\n\t\t\treturn '';\n\t\t}\n\t\tconst upperComponentName = componentName.toUpperCase();\n\t\tif (componentName === helper.HEAD_COMPONENT_NAME) {\n\t\t\treturn upperComponentName;\n\t\t}\n\t\tif (componentName === helper.DOCUMENT_COMPONENT_NAME) {\n\t\t\treturn helper.DOCUMENT_TAG_NAME;\n\t\t}\n\t\treturn helper.COMPONENT_TAG_PREFIX + upperComponentName;\n\t},\n\n\t/**\n\t * Gets a prefixed method of the module that can be invoked.\n\t * @param {Object} module The module implementation.\n\t * @param {string} prefix The method prefix (i.e. handle).\n\t * @param {string?} name The name of the entity to invoke method for\n\t * (will be converted to a camel case).\n\t * @returns {Function} The method to invoke.\n\t */\n\tgetMethodToInvoke: (module, prefix, name) => {\n\t\tif (!module || typeof (module) !== 'object') {\n\t\t\treturn defaultPromiseMethod;\n\t\t}\n\t\tconst methodName = helper.getCamelCaseName(prefix, name);\n\t\tif (typeof (module[methodName]) === 'function') {\n\t\t\treturn module[methodName].bind(module);\n\t\t}\n\t\tif (typeof (module[prefix]) === 'function') {\n\t\t\treturn module[prefix].bind(module, name);\n\t\t}\n\n\t\treturn defaultPromiseMethod;\n\t},\n\n\t/**\n\t * Gets a name in the camel case for anything.\n\t * @param {string} prefix The prefix for the name.\n\t * @param {string} name The name to convert.\n\t * @returns {string} Name in the camel case.\n\t */\n\tgetCamelCaseName: (prefix, name) => {\n\t\tif (!name) {\n\t\t\treturn '';\n\t\t}\n\t\tif (prefix) {\n\t\t\tname = `${prefix}-${name}`;\n\t\t}\n\t\treturn name\n\t\t\t.replace(/(?:[^a-z0-9]+)(\\w)/gi, (space, letter) => letter.toUpperCase())\n\t\t\t.replace(/(^[^a-z0-9])|([^a-z0-9]$)/gi, '');\n\t},\n\n\t/**\n\t * Gets a safe promise resolved by the action.\n\t * @param {Function} action The action to wrap with a safe promise.\n\t * @returns {Promise} The promise for the done action.\n\t */\n\tgetSafePromise: action => {\n\t\ttry {\n\t\t\treturn Promise.resolve(action());\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n};\n\n/**\n * Just returns a resolved promise.\n * @returns {Promise} The promise for nothing.\n */\nfunction defaultPromiseMethod() {\n\treturn Promise.resolve();\n}\n\nmodule.exports = helper;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/helpers/propertyHelper.js":"'use strict';\n\nmodule.exports = {\n\n\t/**\n\t * Defines a read-only property.\n\t * @param {Object} object The object to define a property in.\n\t * @param {string} name The name of the property.\n\t * @param {*} value The value of the property.\n\t */\n\tdefineReadOnly: (object, name, value) => {\n\t\tObject.defineProperty(object, name, {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: false,\n\t\t\twritable: false,\n\t\t\tvalue\n\t\t});\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/providers/ModuleApiProvider.js":"'use strict';\n\nconst ModuleApiProviderBase = require('./../base/ModuleApiProviderBase');\n\nconst SCRIPT_TAG_REGEXP = /<(\\/)?(script)>/ig;\nconst SCRIPT_TAG_REPLACEMENT = '&lt;$1$2&gt;';\n\n/**\n * Implements the module API provider for the server environment.\n */\nclass ModuleApiProvider extends ModuleApiProviderBase {\n\n\t/**\n\t * Creates a new instance of the the module API provider.\n\t * @param {ServiceLocator} locator Service locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\t\tsuper(locator);\n\n\t\t/**\n\t\t * Current set of done actions.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis.actions = {\n\t\t\tredirectedTo: '',\n\t\t\tisNotFoundCalled: false,\n\t\t\tisFragmentCleared: false\n\t\t};\n\t}\n\n\t/**\n\t * Returns false because the environment is supposed to be the server.\n\t * @return {boolean} false.\n\t */\n\tget isBrowser() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns true because the environment is supposed to be the server.\n\t * @return {boolean} true.\n\t */\n\tget isServer() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Sets the \"not found\" flag which means Catberry should hand over\n\t * request handling to the next middleware.\n\t * @returns {Promise} The promise for finished work.\n\t */\n\tnotFound() {\n\t\tthis.actions.isNotFoundCalled = true;\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Redirects the current page to the specified URI using 302 HTTP status code.\n\t * @param {string} uriString The URI to direct.\n\t * @returns {Promise} The promise for finished work.\n\t */\n\tredirect(uriString) {\n\t\tthis.actions.redirectedTo = uriString;\n\t\tthis.actions.redirectionStatusCode = 302;\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Redirects the current page to the specified URI using 301 HTTP status code.\n\t * @param {string} uriString The URI to direct.\n\t * @returns {Promise} The promise for finished work.\n\t */\n\tpermRedirect(uriString) {\n\t\tthis.actions.redirectedTo = uriString;\n\t\tthis.actions.redirectionStatusCode = 301;\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Clears current URI's fragment.\n\t * @returns {Promise} The promise for finished work.\n\t */\n\tclearFragment() {\n\t\tthis.actions.isFragmentCleared = true;\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Gets inline script for making stored actions.\n\t * @returns {string} SCRIPT tag with inline JavaScript to make actions.\n\t */\n\tgetInlineScript() {\n\t\tvar scriptLines = '';\n\n\t\tif (this.cookie.setCookie.length > 0) {\n\t\t\tthis.cookie.setCookie\n\t\t\t\t.forEach(cookieSetup => (scriptLines += `window.document.cookie = '${this._escapeString(cookieSetup)}';`));\n\t\t\tthis.cookie.setCookie = [];\n\t\t}\n\n\t\tif (this.actions.redirectedTo) {\n\t\t\tscriptLines += `window.location.assign('${this._escapeString(this.actions.redirectedTo)}');`;\n\t\t\tthis.actions.redirectedTo = null;\n\t\t\tthis.actions.redirectionStatusCode = null;\n\t\t}\n\n\t\tif (this.actions.isFragmentCleared) {\n\t\t\tscriptLines += 'window.location.hash = \\'\\';';\n\t\t\tthis.actions.isFragmentCleared = false;\n\t\t}\n\n\t\tif (scriptLines.length > 0) {\n\t\t\tscriptLines = scriptLines.replace(SCRIPT_TAG_REGEXP, SCRIPT_TAG_REPLACEMENT);\n\t\t\tscriptLines = `<script>${scriptLines}</script>`;\n\t\t}\n\n\t\treturn scriptLines;\n\t}\n\n\t/**\n\t * Escapes a string for including into the inline script.\n\t * @param {string} str The string to escape.\n\t */\n\t_escapeString(str) {\n\t\treturn str.replace(/['\\\\]/g, '\\\\$&');\n\t}\n}\nmodule.exports = ModuleApiProvider;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/base/ModuleApiProviderBase.js":"'use strict';\n\n/**\n * Implements the basic Module API Provider class for both server\n * and browser environments.\n */\nclass ModuleApiProviderBase {\n\n\t/**\n\t * Creates a new instance of the basic API provider.\n\t * @param {ServiceLocator} locator Service locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\n\t\t/**\n\t\t * Current service locator.\n\t\t * @type {ServiceLocator}\n\t\t */\n\t\tthis.locator = locator;\n\n\t\t/**\n\t\t * Current cookie provider.\n\t\t * @type {CookieWrapper}\n\t\t */\n\t\tthis.cookie = locator.resolve('cookieWrapper');\n\n\t\t/**\n\t\t * Current event bus.\n\t\t * @type {EventEmitter}\n\t\t * @private\n\t\t */\n\t\tthis._eventBus = locator.resolve('eventBus');\n\t}\n\n\t/**\n\t * Subscribes on the specified event in Catberry.\n\t * @param {string} eventName The name of the event.\n\t * @param {Function} handler The event handler.\n\t * @returns {ModuleApiProviderBase} This object for chaining.\n\t */\n\ton(eventName, handler) {\n\t\tcheckEventNameAndHandler(eventName, handler);\n\t\tthis._eventBus.on(eventName, handler);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Subscribes on the specified event in Catberry to handle it once.\n\t * @param {string} eventName The name of the event.\n\t * @param {Function} handler The event handler.\n\t * @returns {ModuleApiProviderBase} This object for chaining.\n\t */\n\tonce(eventName, handler) {\n\t\tcheckEventNameAndHandler(eventName, handler);\n\t\tthis._eventBus.once(eventName, handler);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes the specified handler from the specified event.\n\t * @param {string} eventName The name of the event.\n\t * @param {Function} handler The event handler.\n\t * @returns {ModuleApiProviderBase} This object for chaining.\n\t */\n\tremoveListener(eventName, handler) {\n\t\tcheckEventNameAndHandler(eventName, handler);\n\t\tthis._eventBus.removeListener(eventName, handler);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes all handlers from the specified event in Catberry.\n\t * @param {string} eventName The name of the event.\n\t * @returns {ModuleApiProviderBase} This object for chaining.\n\t */\n\tremoveAllListeners(eventName) {\n\t\tcheckEventNameAndHandler(eventName, stub);\n\t\tthis._eventBus.removeAllListeners(eventName);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Gets URI for the named route and specified parameters.\n\t * @param {string} name Name of the route.\n\t * @param {Object} values Set of route parameter values.\n\t * @returns {string} URI string.\n\t */\n\tgetRouteURI(name, values) {\n\t\tconst stateProvider = this.locator.resolve('stateProvider');\n\t\treturn stateProvider.getRouteURI(name, values);\n\t}\n}\n\n/**\n * Checks if an event name is a string and handler is a function.\n * @param {*} eventName The name of the event to check.\n * @param {*} handler The event handler to check.\n */\nfunction checkEventNameAndHandler(eventName, handler) {\n\tif (typeof (eventName) !== 'string') {\n\t\tthrow new Error('Event name should be a string');\n\t}\n\n\tif (typeof (handler) !== 'function') {\n\t\tthrow new Error('Event handler should be a function');\n\t}\n}\n\n/**\n * Does nothing. It is used as a default callback.\n */\nfunction stub() {}\n\nmodule.exports = ModuleApiProviderBase;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/CookieWrapper.js":"'use strict';\n\nconst CookieWrapperBase = require('./base/CookieWrapperBase');\n\n/**\n * Implements the Cookie Wrapper class for the server environment.\n */\nclass CookieWrapper extends CookieWrapperBase {\n\n\t/**\n\t * Creates a new instance of the server-side cookie wrapper.\n\t */\n\tconstructor() {\n\t\tsuper();\n\n\t\t/**\n\t\t * Current list of cookie strings set in the instance.\n\t\t * @type {Array}\n\t\t */\n\t\tthis.setCookie = [];\n\n\t\t/**\n\t\t * Current list of cookie setups set in the instance.\n\t\t * @type {Array}\n\t\t */\n\t\tthis.cookieSetups = [];\n\n\t\t/**\n\t\t * Current cookie string.\n\t\t * @type {string}\n\t\t * @private\n\t\t */\n\t\tthis._initialCookieString = '';\n\t}\n\n\t/**\n\t * Initializes the instance with the specified cookie string.\n\t * @param {string} cookieString The cookie string.\n\t */\n\tinitWithString(cookieString) {\n\t\tthis._initialCookieString = cookieString;\n\t}\n\n\t/**\n\t * Gets current cookie string.\n\t * @returns {string} The cookie string.\n\t */\n\tgetCookieString() {\n\t\tvar string = this._initialCookieString;\n\t\tthis.cookieSetups.forEach(cookieSetup => {\n\t\t\tstring += `${string ? '; ' : ''}${cookieSetup.key}=${cookieSetup.value}`;\n\t\t});\n\t\treturn string;\n\t}\n\n\t/**\n\t * Sets a cookie to the instance.\n\t * @param {Object} cookieSetup The cookie setup object.\n\t * @param {string} cookieSetup.key The cookie key.\n\t * @param {string} cookieSetup.value The cookie's value.\n\t * @param {number?} cookieSetup.maxAge The cookie's max age in seconds.\n\t * @param {Date?} cookieSetup.expires The expiration date.\n\t * @param {string?} cookieSetup.path The cookie's URI path.\n\t * @param {string?} cookieSetup.domain The cookie's domain.\n\t * @param {boolean?} cookieSetup.secure Is the cookie secured.\n\t * @param {boolean?} cookieSetup.httpOnly Is the cookie HTTP only.\n\t * @returns {string} The cookie setup string.\n\t */\n\tset(cookieSetup) {\n\t\tconst cookie = this._convertToCookieSetup(cookieSetup);\n\t\tthis.setCookie.push(cookie);\n\t\tthis.cookieSetups.push(cookieSetup);\n\t\treturn cookie;\n\t}\n}\n\nmodule.exports = CookieWrapper;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/base/CookieWrapperBase.js":"'use strict';\n\n/**\n * Implements the basic Cookie Wrapper class for both server\n * and browser environments.\n */\nclass CookieWrapperBase {\n\n\t/**\n\t * Gets a map of cookie values by their names.\n\t * @returns {Object} The cookies map by their names.\n\t */\n\tgetAll() {\n\t\tconst string = this.getCookieString();\n\t\treturn this._parseCookieString(string);\n\t}\n\n\t/**\n\t * Gets a cookie value by its name.\n\t * @param {string} name The cookie name.\n\t * @returns {string} The cookie value.\n\t */\n\tget(name) {\n\t\tif (typeof (name) !== 'string') {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this.getAll()[name] || '';\n\t}\n\n\t/**\n\t * Parses a cookie string into the map of cookie key/value pairs.\n\t * @param {string} string The cookie string.\n\t * @returns {Object} The object with cookie values by their names.\n\t * @protected\n\t */\n\t_parseCookieString(string) {\n\t\tconst cookie = Object.create(null);\n\n\t\tif (typeof (string) !== 'string') {\n\t\t\treturn cookie;\n\t\t}\n\t\tstring\n\t\t\t.split(/; */)\n\t\t\t.forEach(cookiePair => {\n\t\t\t\tconst equalsIndex = cookiePair.indexOf('=');\n\t\t\t\tif (equalsIndex < 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst key = cookiePair\n\t\t\t\t\t.substring(0, equalsIndex)\n\t\t\t\t\t.trim();\n\n\t\t\t\tcookie[key] = cookiePair\n\t\t\t\t\t.substring(equalsIndex + 1)\n\t\t\t\t\t.trim()\n\t\t\t\t\t.replace(/^\"|\"$/g, '');\n\t\t\t});\n\n\t\treturn cookie;\n\t}\n\n\t/**\n\t * Converts a cookie setup object to the cookie string.\n\t * @param {Object} cookieSetup The cookie setup object.\n\t * @param {string} cookieSetup.key The cookie key.\n\t * @param {string} cookieSetup.value The cookie's value.\n\t * @param {number?} cookieSetup.maxAge The cookie's max age in seconds.\n\t * @param {Date?} cookieSetup.expires The expiration date.\n\t * @param {string?} cookieSetup.path The cookie's URI path.\n\t * @param {string?} cookieSetup.domain The cookie's domain.\n\t * @param {boolean?} cookieSetup.secure Is the cookie secured.\n\t * @param {boolean?} cookieSetup.httpOnly Is the cookie HTTP only.\n\t * @returns {string} The cookie string.\n\t * @protected\n\t */\n\t_convertToCookieSetup(cookieSetup) {\n\t\tif (typeof (cookieSetup.key) !== 'string' ||\n\t\t\ttypeof (cookieSetup.value) !== 'string') {\n\t\t\tthrow new Error('Wrong key or value');\n\t\t}\n\n\t\tvar cookie = `${cookieSetup.key}=${cookieSetup.value}`;\n\n\t\t// http://tools.ietf.org/html/rfc6265#section-4.1.1\n\t\tif (typeof (cookieSetup.maxAge) === 'number') {\n\t\t\tcookie += `; Max-Age=${cookieSetup.maxAge.toFixed()}`;\n\t\t\tif (!cookieSetup.expires) {\n\t\t\t\t// by default expire date = current date + max-age in seconds\n\t\t\t\tcookieSetup.expires = new Date(Date.now() +\n\t\t\t\t\tcookieSetup.maxAge * 1000);\n\t\t\t}\n\t\t}\n\t\tif (cookieSetup.expires instanceof Date) {\n\t\t\tcookie += `; Expires=${cookieSetup.expires.toUTCString()}`;\n\t\t}\n\t\tif (typeof (cookieSetup.path) === 'string') {\n\t\t\tcookie += `; Path=${cookieSetup.path}`;\n\t\t}\n\t\tif (typeof (cookieSetup.domain) === 'string') {\n\t\t\tcookie += `; Domain=${cookieSetup.domain}`;\n\t\t}\n\t\tif (typeof (cookieSetup.secure) === 'boolean' &&\n\t\t\tcookieSetup.secure) {\n\t\t\tcookie += '; Secure';\n\t\t}\n\t\tif (typeof (cookieSetup.httpOnly) === 'boolean' &&\n\t\t\tcookieSetup.httpOnly) {\n\t\t\tcookie += '; HttpOnly';\n\t\t}\n\n\t\treturn cookie;\n\t}\n}\n\nmodule.exports = CookieWrapperBase;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/builders/BrowserBundleBuilder.js":"'use strict';\n\nconst path = require('path');\nconst stream = require('stream');\nconst fs = require('fs');\nconst pfs = require('../promises/fs');\nconst mkdirp = require('mkdirp');\nconst watchify = require('watchify');\nconst babelify = require('babelify');\nconst babelEnv = require('babel-preset-env');\nconst babili = require('babel-preset-babili');\nconst browserify = require('browserify');\nconst hrTimeHelper = require('../helpers/hrTimeHelper');\n\nconst WORKING_DIR = process.cwd();\nconst DEFAULT_PUBLIC_DIRECTORY = path.join(WORKING_DIR, 'public');\nconst TEMPORARY_APP_DEFINITIONS_FILENAME = '.appDefinitions.js';\nconst BROWSER_SCRIPT_FILENAME = 'browser.js';\nconst APP_DEFAULT_FILENAME = 'app.js';\nconst EXTERNALS_DEFAULT_FILENAME = 'externals.js';\nconst APP_DEPENDENCY_ID_REGEXP = process.platform === 'win32' ?\t/^(\\.|\\w:)/ :\t/^[\\/.]/;\n\nvar packageDescriptionString = '';\n\ntry {\n\tconst packageDescription = require(path.join(WORKING_DIR, 'package.json'));\n\tif (packageDescription &&\n\t\tpackageDescription.name &&\n\t\tpackageDescription.version) {\n\t\tpackageDescriptionString = `\n/**\n * ${packageDescription.name}: ${packageDescription.version}\n * Build Date: ${(new Date()).toString()}\n */\n\n`;\n\t}\n} catch (e) {\n\t// ok, nothing to do here\n}\n\n/**\n * Implements the bundle builder module.\n */\nclass BrowserBundleBuilder {\n\n\t/**\n\t * Creates a new instance of the browser bundle builder.\n\t * @param {ServiceLocator} locator Service locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\t\tconst config = locator.resolve('config');\n\n\t\t/**\n\t\t * Is current application mode release.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._isRelease = Boolean(config.isRelease);\n\n\t\t/**\n\t\t * Current path where to publish bundle.\n\t\t * @type {string}\n\t\t * @private\n\t\t */\n\t\tthis._publicPath = config.publicDirectoryPath || DEFAULT_PUBLIC_DIRECTORY;\n\n\t\t/**\n\t\t * Current path to the application bundle file.\n\t\t * @type {string}\n\t\t * @private\n\t\t */\n\t\tthis._appPath = path.join(this._publicPath, (config.appBundleFilename || APP_DEFAULT_FILENAME));\n\n\t\t/**\n\t\t * Current path to the externals bunlde file.\n\t\t * @type {string}\n\t\t * @private\n\t\t */\n\t\tthis._externalsPath = path.join(this._publicPath, (config.externalsBundleFilename || EXTERNALS_DEFAULT_FILENAME));\n\n\t\t/**\n\t\t * Current path to the __appDefinitions.js.\n\t\t * @type {string}\n\t\t * @private\n\t\t */\n\t\tthis._appDefinitionsPath = path.join(WORKING_DIR, TEMPORARY_APP_DEFINITIONS_FILENAME);\n\n\t\t/**\n\t\t * Current path to the browser.js.\n\t\t * @type {string}\n\t\t * @private\n\t\t */\n\t\tthis._entryPath = path.join(WORKING_DIR, BROWSER_SCRIPT_FILENAME);\n\n\t\t/**\n\t\t * Current service locator.\n\t\t * @type {ServiceLocator}\n\t\t * @private\n\t\t */\n\t\tthis._serviceLocator = locator;\n\n\t\t/**\n\t\t * Current event bus.\n\t\t * @type {EventEmitter}\n\t\t * @private\n\t\t */\n\t\tthis._eventBus = locator.resolve('eventBus');\n\n\t\t/**\n\t\t * Current app definitions builder.\n\t\t * @type {AppDefinitionsBuilder}\n\t\t * @private\n\t\t */\n\t\tthis._appDefinitionsBuilder = locator.resolve('appDefinitionsBuilder');\n\n\t\t/**\n\t\t * Current component finder.\n\t\t * @type {ComponentFinder}\n\t\t * @private\n\t\t */\n\t\tthis._componentFinder = locator.resolve('componentFinder');\n\n\t\t/**\n\t\t * Current store finder.\n\t\t * @type {StoreFinder}\n\t\t * @private\n\t\t */\n\t\tthis._storeFinder = locator.resolve('storeFinder');\n\n\t\t/**\n\t\t * Current post build actions list.\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._postBuildActions = [];\n\t\ttry {\n\t\t\tthis._postBuildActions = locator.resolveAll('postBuildAction');\n\t\t} catch (e) {\n\t\t\t// nothing to do here\n\t\t}\n\n\t\t/**\n\t\t * Current browserify transformations list.\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._browserifyTransformations = [];\n\t\ttry {\n\t\t\tthis._browserifyTransformations = locator.resolveAll('browserifyTransformation');\n\t\t} catch (e) {\n\t\t\t// nothing to do here\n\t\t}\n\n\t\t/**\n\t\t * Current browserify plugins list.\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._browserifyPlugins = [];\n\t\ttry {\n\t\t\tthis._browserifyPlugins = locator.resolveAll('browserifyPlugin');\n\t\t} catch (e) {\n\t\t\t// nothing to do here\n\t\t}\n\n\t\t/**\n\t\t * Current Browserify app bundler.\n\t\t * @type {Browserify}\n\t\t * @private\n\t\t */\n\t\tthis._appBundler = null;\n\n\t\t/**\n\t\t * Current Browserify externals bundler.\n\t\t * @type {Browserify}\n\t\t * @private\n\t\t */\n\t\tthis._externalsBundler = null;\n\n\t\t/**\n\t\t * Current set of external modules.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._externalModules = {};\n\n\t\t/**\n\t\t * Current app definitions cache.\n\t\t * @type {string}\n\t\t * @private\n\t\t */\n\t\tthis._appDefinitionsCache = '';\n\t}\n\n\t/**\n\t * Builds the browser bundle.\n\t * @returns {Promise} The promise for finished work.\n\t */\n\tbuild() {\n\t\treturn pfs.exists(this._publicPath)\n\t\t\t.then(isExists => !isExists ? makeDirectory(this._publicPath) : null)\n\t\t\t.then(() => this._createAppDefinitions())\n\t\t\t.then(() => new Promise((fulfill, reject) => this._createAppBundler()\n\t\t\t\t\t.once('error', reject)\n\t\t\t\t\t.once('bundle', bundleStream => bundleStream\n\t\t\t\t\t\t\t.once('end', fulfill)\n\t\t\t\t\t\t\t.on('error', reject)\n\t\t\t\t\t)\n\t\t\t\t\t.bundle()\n\t\t\t\t)\n\t\t\t)\n\t\t\t.then(() => new Promise((fulfill, reject) => this._createExternalsBundler()\n\t\t\t\t\t.once('error', reject)\n\t\t\t\t\t.once('bundle', bundleStream => bundleStream\n\t\t\t\t\t\t\t.once('end', fulfill)\n\t\t\t\t\t\t\t.on('error', reject)\n\t\t\t\t\t)\n\t\t\t\t\t.bundle()\n\t\t\t\t)\n\t\t\t)\n\n\t\t\t.then(() => this._doPostBuildActions())\n\t\t\t.then(() => this._isRelease ?\n\t\t\t\t\tpfs.unlink(this._appDefinitionsPath) :\n\t\t\t\t\tthis._watch()\n\t\t\t)\n\t\t\t.catch(reason => this._eventBus.emit('error', reason));\n\t}\n\n\t/**\n\t * Creates a app definitions file for the bundler.\n\t * @returns {Promise} The promise for finished work.\n\t * @private\n\t */\n\t_createAppDefinitions() {\n\t\treturn Promise.all([\n\t\t\tthis._storeFinder.find(),\n\t\t\tthis._componentFinder.find()\n\t\t])\n\t\t\t.then(found => this._appDefinitionsBuilder.build(found[0], found[1]))\n\t\t\t.then(realAppDefinitions => {\n\t\t\t\tif (realAppDefinitions === this._appDefinitionsCache) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tthis._appDefinitionsCache = realAppDefinitions;\n\t\t\t\treturn pfs.writeFile(this._appDefinitionsPath, realAppDefinitions);\n\t\t\t});\n\t}\n\n\t/**\n\t * Creates the browserify bundler for the app or re-uses the existing one.\n\t * @returns {Browserify} The browserify instance.\n\t * @private\n\t */\n\t_createAppBundler() {\n\t\tif (this._appBundler) {\n\t\t\treturn this._appBundler;\n\t\t}\n\n\t\tthis._appBundler = browserify(this._entryPath, {\n\t\t\tcache: {},\n\t\t\tpackageCache: {},\n\t\t\tdebug: !this._isRelease,\n\t\t\tfilter: id => {\n\t\t\t\tif (APP_DEPENDENCY_ID_REGEXP.test(id)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tthis._externalModules[id] = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\tthis._appBundler.require(\n\t\t\tthis._appDefinitionsPath, {expose: 'appDefinitions'}\n\t\t);\n\t\tthis._appBundler.external('catberry');\n\n\t\tif (!this._isRelease) {\n\t\t\tthis._appBundler.plugin(watchify);\n\t\t\tthis._eventBus.emit('info', 'Watching files for changes to rebuild the app bundle...');\n\t\t}\n\n\t\tthis._attachExtensionsToBundler(this._appBundler);\n\n\t\tvar startTime;\n\t\tconst resetHandler = () => {\n\t\t\tthis._eventBus.emit('info', `Building browser script bundle for the app at \"${this._appPath}\"...`);\n\t\t\tstartTime = hrTimeHelper.get();\n\t\t};\n\n\t\tthis._appBundler\n\t\t\t.on('update', ids => {\n\t\t\t\tthis._eventBus.emit('appBundleChanged', {\n\t\t\t\t\tpath: this._appPath,\n\t\t\t\t\tchangedFiles: ids\n\t\t\t\t});\n\n\t\t\t\tthis._appBundler.bundle();\n\t\t\t})\n\t\t\t.on('error', error => this._eventBus.emit('error', error))\n\t\t\t.on('reset', resetHandler)\n\t\t\t.on('bundle', sourceStream => {\n\t\t\t\tconst outputStream = fs.createWriteStream(this._appPath);\n\t\t\t\tif (this._isRelease) {\n\t\t\t\t\toutputStream.write(packageDescriptionString);\n\t\t\t\t}\n\t\t\t\toutputStream.once('finish', () => {\n\t\t\t\t\tconst hrTime = hrTimeHelper.get(startTime);\n\t\t\t\t\tthis._eventBus.emit('appBundleBuilt', {\n\t\t\t\t\t\tpath: this._appPath,\n\t\t\t\t\t\thrTime,\n\t\t\t\t\t\ttime: hrTimeHelper.toMilliseconds(hrTime)\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tsourceStream.pipe(outputStream);\n\t\t\t});\n\n\t\tresetHandler(); // to set startTime universally.\n\t\treturn this._appBundler;\n\t}\n\n\t/**\n\t * Creates the browserify bundler for externals or re-uses the existing one.\n\t * @returns {Browserify} The browserify instances.\n\t * @private\n\t */\n\t_createExternalsBundler() {\n\t\tif (this._externalsBundler) {\n\t\t\treturn this._externalsBundler;\n\t\t}\n\n\t\tthis._externalsBundler = browserify({\n\t\t\tcache: {},\n\t\t\tpackageCache: {},\n\t\t\tdebug: !this._isRelease\n\t\t});\n\t\tthis._externalsBundler.require(Object.keys(this._externalModules));\n\t\tthis._externalsBundler.external('appDefinitions');\n\t\tthis._attachExtensionsToBundler(this._externalsBundler);\n\n\t\tconst startTime = hrTimeHelper.get();\n\t\tthis._eventBus.emit('info', `Building browser script bundle for externals at \"${this._externalsPath}\"...`);\n\n\t\tthis._externalsBundler\n\t\t\t.on('error', error => this._eventBus.emit('error', error))\n\t\t\t.on('bundle', sourceStream => {\n\t\t\t\tconst outputStream = fs.createWriteStream(this._externalsPath);\n\t\t\t\toutputStream.once('finish', () => {\n\t\t\t\t\tconst hrTime = hrTimeHelper.get(startTime);\n\t\t\t\t\tthis._eventBus.emit('externalsBundleBuilt', {\n\t\t\t\t\t\tpath: this._externalsPath,\n\t\t\t\t\t\thrTime,\n\t\t\t\t\t\ttime: hrTimeHelper.toMilliseconds(hrTime)\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tsourceStream.pipe(outputStream);\n\t\t\t});\n\n\t\treturn this._externalsBundler;\n\t}\n\n\t/**\n\t * Attaches necessary plugins and transformations to the bundle.\n\t * @param {Browserify} bundler The bundler to attach extensions.\n\t */\n\t_attachExtensionsToBundler(bundler) {\n\t\tconst isDebug = !this._isRelease;\n\n\t\tconst presets = [[\n\t\t\tbabelEnv, {\n\t\t\t\ttargets: {\n\t\t\t\t\tbrowsers: [\n\t\t\t\t\t\t'last 2 versions',\n\t\t\t\t\t\t'not ie <= 10'\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tdebug: isDebug\n\t\t\t}\n\t\t]];\n\n\t\tif (this._isRelease) {\n\t\t\tpresets.push(babili);\n\t\t}\n\n\t\tbundler.transform(babelify, {\n\t\t\tglobal: true,\n\t\t\tast: false,\n\t\t\tcomments: false,\n\t\t\tpresets,\n\t\t\tsourceMap: isDebug\n\t\t});\n\n\t\tthis._setTransformations(bundler);\n\t\tthis._setPlugins(bundler);\n\t}\n\n\t/**\n\t * Does all the registered post build actions.\n\t * @param {number?} index Current action index for recursive calls.\n\t * @private\n\t * @returns {Promise} The promise for finished work.\n\t */\n\t_doPostBuildActions(index) {\n\t\tif (index === undefined) {\n\t\t\t// we start from the end because the list a stack\n\t\t\tindex = this._postBuildActions.length - 1;\n\t\t}\n\t\tif (index < 0) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() => {\n\t\t\t\tconst actionObject = this._postBuildActions[index];\n\t\t\t\tif (!actionObject ||\n\t\t\t\t\ttypeof (actionObject) !== 'object' ||\n\t\t\t\t\ttypeof (actionObject.action) !== 'function') {\n\t\t\t\t\tthis._eventBus.emit('warn', 'The post-build action has an incorrect interface, skipping...');\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\treturn actionObject.action(this._storeFinder, this._componentFinder);\n\t\t\t})\n\t\t\t.catch(reason => this._eventBus.emit('error', reason))\n\t\t\t.then(() => this._doPostBuildActions(index - 1));\n\t}\n\n\t/**\n\t * Watches the file's changes.\n\t * @private\n\t */\n\t_watch() {\n\t\tconst watchHandler = this._createAppDefinitions.bind(this);\n\t\tthis._componentFinder.watch();\n\t\tthis._componentFinder\n\t\t\t.on('add', watchHandler)\n\t\t\t.on('unlink', watchHandler)\n\t\t\t.on('changeTemplates', watchHandler);\n\n\t\tthis._storeFinder.watch();\n\t\tthis._storeFinder\n\t\t\t.on('add', watchHandler)\n\t\t\t.on('unlink', watchHandler);\n\t}\n\n\t/**\n\t * Sets the list of current transformations to the bundler.\n\t */\n\t_setTransformations() {\n\t\t// traverse items in the reversed order\n\t\tvar currentIndex = this._browserifyTransformations.length - 1;\n\n\t\twhile (currentIndex >= 0) {\n\t\t\tconst currentTransformation = this._browserifyTransformations[currentIndex];\n\t\t\tcurrentIndex--;\n\t\t\tif (!currentTransformation ||\n\t\t\t\ttypeof (currentTransformation) !== 'object' ||\n\t\t\t\ttypeof (currentTransformation.transform) !== 'function') {\n\t\t\t\tthis._eventBus.emit('warn', 'The browserify transformation has an incorrect interface, skipping...');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._appBundler.transform(\n\t\t\t\tcurrentTransformation.transform, currentTransformation.options\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the list of current plugins to the bundler.\n\t */\n\t_setPlugins() {\n\t\tvar currentIndex = this._browserifyPlugins.length - 1;\n\n\t\twhile (currentIndex >= 0) {\n\t\t\tconst currentPlugin = this._browserifyPlugins[currentIndex];\n\t\t\tcurrentIndex--;\n\t\t\tif (!currentPlugin ||\n\t\t\t\ttypeof (currentPlugin) !== 'object' ||\n\t\t\t\ttypeof (currentPlugin.plugin) !== 'function') {\n\t\t\t\tthis._eventBus.emit('warn', 'The browserify plugin has an incorrect interface, skipping...');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._appBundler.plugin(\n\t\t\t\tcurrentPlugin.plugin, currentPlugin.options\n\t\t\t);\n\t\t}\n\t}\n}\n\n/**\n * Creates all necessary directories for path.\n * @param {string} dirPath Directory path.\n * @returns {Promise} Promise for nothing.\n */\nfunction makeDirectory(dirPath) {\n\treturn new Promise((fulfill, reject) => {\n\t\tmkdirp(dirPath, error => {\n\t\t\tif (error) {\n\t\t\t\treject(error);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfulfill();\n\t\t});\n\t});\n}\n\nmodule.exports = BrowserBundleBuilder;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/promises/fs.js":"'use strict';\n\nconst fs = require('fs');\nconst helper = require('./promiseHelper');\n\nmodule.exports = {\n\texists: toCheck => new Promise(fulfill => fs.exists(toCheck, isExists => fulfill(isExists))),\n\tmakeDir: helper.callbackToPromise(fs.mkdir),\n\treadFile: helper.callbackToPromise(fs.readFile),\n\twriteFile: helper.callbackToPromise(fs.writeFile),\n\tunlink: helper.callbackToPromise(fs.unlink)\n};\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/promises/promiseHelper.js":"'use strict';\n\nmodule.exports = {\n\n\t/**\n\t * Converts a method with a callback to the method that returns a promise.\n\t * @param {Function} methodWithCallback The method with a callback.\n\t * @returns {Function} The method that returns a promise.\n\t */\n\tcallbackToPromise: methodWithCallback => {\n\n\t\t/* eslint no-invalid-this:0 */\n\t\treturn function(...args) {\n\t\t\treturn new Promise((fulfill, reject) => {\n\t\t\t\targs.push((error, result) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tfulfill(result);\n\t\t\t\t});\n\t\t\t\tmethodWithCallback.apply(this, args);\n\t\t\t});\n\t\t};\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/helpers/hrTimeHelper.js":"'use strict';\n\nmodule.exports = {\n\n\t/**\n\t * Gets the high resolution time or the difference between\n\t * previous and current time.\n\t * @param {Array?} Previous high resolution timestamp.\n\t * @returns {Array} The high resolution time tuple.\n\t */\n\tget: process.hrtime,\n\n\t/**\n\t * Converts the high resolution timestamp to the text message.\n\t * @param {Array} The high resolution time tuple.\n\t * @returns {string} Time message.\n\t */\n\ttoMessage: require('pretty-hrtime'),\n\n\t/**\n\t * Converts high resolution time to milliseconds number.\n\t * @param {Array} hrTime The high resolution time tuple.\n\t */\n\ttoMilliseconds: hrTime => {\n\t\treturn hrTime[0] * 1e3 + Math.round(hrTime[1] / 1e6);\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/builders/AppDefinitionsBuilder.js":"'use strict';\n\nconst path = require('path');\nconst pfs = require('../promises/fs');\nconst hrTimeHelper = require('../helpers/hrTimeHelper');\nconst moduleHelper = require('../helpers/moduleHelper');\nconst templateHelper = require('../helpers/templateHelper');\nconst loadHelper = require('../helpers/loadHelper');\nconst requireHelper = require('../helpers/requireHelper');\nconst RouteParser = require('../tokenizers/RouteParser');\n\nconst APP_DEFINITIONS_FILENAME = 'appDefinitions.js';\nconst LIB_ROOT_PATH = path.join(__dirname, '..');\nconst STORES_REPLACE = '/** __stores **/';\nconst COMPONENTS_REPLACE = '/** __components **/';\nconst ROUTE_DESCRIPTORS_REPLACE = '\\'__routes\\'';\nconst ROUTE_DEFINITIONS_REPLACE = '\\'__routeDefinitions\\'';\nconst ROUTE_DEFINITIONS_FILENAME = 'routes.js';\n\n/**\n * Implements the app definitions builder module.\n */\nclass AppDefinitionsBuilder {\n\n\t/**\n\t * Creates a new instance of the app definitions builder.\n\t * @param {ServiceLocator} locator The Service Locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\n\t\t/**\n\t\t * Current event bus.\n\t\t * @type {EventEmitter}\n\t\t * @private\n\t\t */\n\t\tthis._eventBus = locator.resolve('eventBus');\n\n\t\t/**\n\t\t * Current template provider list.\n\t\t * @type {Array<TemplateProvider>}\n\t\t * @private\n\t\t */\n\t\tthis._templateProviders = templateHelper.resolveTemplateProviders(locator);\n\n\t\t/**\n\t\t * Current route parser.\n\t\t * @type {RouteParser}\n\t\t * @private\n\t\t */\n\t\tthis._routeParser = new RouteParser();\n\t}\n\n\t/**\n\t * Creates a real app definitions code from the template.\n\t * @param {Object} stores The found stores by their names.\n\t * @param {Object} components The found components by their names.\n\t * @returns {Promise<string>} The promise for the source code of the app definitions.\n\t */\n\tbuild(stores, components) {\n\t\tconst appDefinitionsTemplatePath = path.join(\n\t\t\tLIB_ROOT_PATH,\n\t\t\tAPP_DEFINITIONS_FILENAME\n\t\t);\n\t\tconst routeDefinitionsPath = path.join(\n\t\t\tprocess.cwd(),\n\t\t\tROUTE_DEFINITIONS_FILENAME\n\t\t);\n\n\t\tconst startTime = hrTimeHelper.get();\n\t\tthis._eventBus.emit('info', `Building app definitions using the template \"${appDefinitionsTemplatePath}\"...`);\n\n\t\treturn pfs.readFile(appDefinitionsTemplatePath, {\n\t\t\tencoding: 'utf8'\n\t\t})\n\t\t\t.then(file => Promise\n\t\t\t\t.all([\n\t\t\t\t\tthis._generateStoreDescriptors(stores),\n\t\t\t\t\tthis._generateComponentDescriptors(components)\n\t\t\t\t])\n\t\t\t\t.then(results => ({\n\t\t\t\t\tfile,\n\t\t\t\t\tstores: results[0],\n\t\t\t\t\tcomponents: results[1]\n\t\t\t\t})))\n\t\t\t// check if paths exist and create require statements or undefined\n\t\t\t.then(context =>\n\t\t\t\tpfs.exists(routeDefinitionsPath)\n\t\t\t\t\t.then(isExists => {\n\t\t\t\t\t\tconst filePath = path.relative(\n\t\t\t\t\t\t\tprocess.cwd(), requireHelper.getValidPath(routeDefinitionsPath)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst requireString = isExists ? `require('./${filePath}')` : 'null';\n\t\t\t\t\t\tconst routeDescriptors = [];\n\n\t\t\t\t\t\tif (isExists) {\n\t\t\t\t\t\t\tconst routeDefinitions = require(routeDefinitionsPath);\n\n\t\t\t\t\t\t\t/* eslint max-nested-callbacks: 0 */\n\t\t\t\t\t\t\trouteDefinitions.forEach(definition => {\n\t\t\t\t\t\t\t\tif (typeof (definition) === 'string') {\n\t\t\t\t\t\t\t\t\trouteDescriptors.push(this._routeParser.parseRouteExpression(definition));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (typeof (definition) === 'object' &&\n\t\t\t\t\t\t\t\t\t\ttypeof (definition.expression) === 'string') {\n\t\t\t\t\t\t\t\t\trouteDescriptors.push(this._routeParser.parseRouteExpression(definition.expression));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn context.file\n\t\t\t\t\t\t\t.replace(COMPONENTS_REPLACE, context.components)\n\t\t\t\t\t\t\t.replace(STORES_REPLACE, context.stores)\n\t\t\t\t\t\t\t.replace(ROUTE_DEFINITIONS_REPLACE, requireString)\n\t\t\t\t\t\t\t.replace(ROUTE_DESCRIPTORS_REPLACE, JSON.stringify(routeDescriptors));\n\t\t\t\t\t})\n\t\t\t)\n\t\t\t.then(appDefinitions => {\n\t\t\t\tconst hrTime = hrTimeHelper.get(startTime);\n\t\t\t\tthis._eventBus.emit('appDefinitionsBuilt', {\n\t\t\t\t\ttemplate: appDefinitionsTemplatePath,\n\t\t\t\t\thrTime,\n\t\t\t\t\ttime: hrTimeHelper.toMilliseconds(hrTime)\n\t\t\t\t});\n\t\t\t\treturn appDefinitions;\n\t\t\t})\n\t\t\t.catch(reason => this._eventBus.emit('error', reason));\n\t}\n\n\t/**\n\t * Generates inline descriptors for each store.\n\t * @param {Object} stores The found stores by their names.\n\t * @returns {Promise<string>} The promise for the JSON string that describes the stores.\n\t * @private\n\t */\n\t_generateStoreDescriptors(stores) {\n\t\tconst storeRequires = [];\n\t\tObject\n\t\t\t.keys(stores)\n\t\t\t.forEach(storeName => {\n\t\t\t\tconst filePath = requireHelper.getValidPath(\n\t\t\t\t\tpath.relative(process.cwd(), stores[storeName].path)\n\t\t\t\t);\n\t\t\t\tconst requireExpression = stores[storeName].path ?\n\t\t\t\t\t`require('./${filePath}')` : null;\n\t\t\t\tif (!requireExpression) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tstoreRequires.push(`\\n{name: '${storeName}', constructor: ${requireExpression}}`);\n\t\t\t});\n\t\treturn Promise.resolve(storeRequires.join(','));\n\t}\n\n\t/**\n\t * Generates inline descriptors for each component.\n\t * @param {Object} components The found components by their names.\n\t * @returns {Promise<string>} The promise for the JSON string that describes the components.\n\t * @private\n\t */\n\t_generateComponentDescriptors(components) {\n\t\tconst promises = [];\n\n\t\tObject.keys(components)\n\t\t\t.forEach(componentName => {\n\t\t\t\tconst componentDetails = components[componentName];\n\t\t\t\tconst logicFile = components[componentName].properties.logic ||\n\t\t\t\t\t\tmoduleHelper.DEFAULT_LOGIC_FILENAME;\n\t\t\t\tconst logicPath = path.resolve(path.dirname(componentDetails.path), logicFile);\n\t\t\t\tconst relativeLogicPath = path.relative(process.cwd(), logicPath);\n\n\t\t\t\tvar constructor;\n\n\t\t\t\ttry {\n\t\t\t\t\tconstructor = require(logicPath);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis._eventBus.emit('error', e);\n\t\t\t\t}\n\n\t\t\t\tif (typeof (constructor) !== 'function' ||\n\t\t\t\t\ttypeof (componentDetails.properties.template) !== 'string') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst component = Object.create(componentDetails);\n\t\t\t\tconst promise = loadHelper.loadTemplateSources(component)\n\t\t\t\t\t.then(() => loadHelper.assignTemplateProviders(component, this._templateProviders))\n\t\t\t\t\t.then(() => loadHelper.compileTemplates(component))\n\t\t\t\t\t.then(() => {\n\t\t\t\t\t\tconst filePath = requireHelper.getValidPath(relativeLogicPath);\n\t\t\t\t\t\tconst requireString = `require('./${filePath}')`;\n\t\t\t\t\t\tconst errorTemplateString = component.compiledErrorTemplate !== null ?\n\t\t\t\t\t\t\t\t\t\t`'${escapeTemplateSource(component.compiledErrorTemplate)}'` : 'null';\n\t\t\t\t\t\tconst errorTemplateProvider = component.errorTemplateProvider !== null ?\n\t\t\t\t\t\t\t\t\t\t`'${component.errorTemplateProvider.getName()}'` : 'null';\n\t\t\t\t\t\treturn `\n{\n\tname: '${componentName}',\n\tconstructor: ${requireString},\n\tproperties: ${JSON.stringify(componentDetails.properties)},\n\ttemplateProviderName: '${component.templateProvider.getName()}',\n\tcompiledTemplate: '${escapeTemplateSource(component.compiledTemplate)}',\n\terrorTemplateProviderName: ${errorTemplateProvider},\n\tcompiledErrorTemplate: ${errorTemplateString}\n}`;\n\t\t\t\t\t});\n\t\t\t\tpromises.push(promise);\n\t\t\t});\n\n\t\treturn Promise\n\t\t\t.all(promises)\n\t\t\t.then(components => components.join(','));\n\t}\n}\n\n/**\n * Escapes template source code for including into the app definitions.\n * @param {string} source The compiled template source.\n * @returns {string} The escaped string.\n */\nfunction escapeTemplateSource(source) {\n\treturn source\n\t\t.replace(/(\\\\.)/g, '\\\\$&')\n\t\t.replace(/'/g, '\\\\\\'')\n\t\t.replace(/\\r/g, '\\\\r')\n\t\t.replace(/\\n/g, '\\\\n')\n\t\t.replace(/\\t/g, '\\\\t');\n}\n\nmodule.exports = AppDefinitionsBuilder;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/helpers/templateHelper.js":"'use strict';\n\nconst moduleHelper = require('./moduleHelper');\n\nconst helper = {\n\n\t/**\n\t * Registers templates into the component and template providers.\n\t * @param {Object} component The component.\n\t * @param {{template: string, errorTemplate: string}} templates\n\t * The compiled templates.\n\t */\n\tregisterTemplates: component => {\n\t\tcomponent.templateProvider.registerCompiled(component.name, component.compiledTemplate);\n\n\t\tcomponent.template = {\n\t\t\trender: context => component.templateProvider.render(component.name, context)\n\t\t};\n\n\t\tif (!component.compiledErrorTemplate) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst errorTemplateName = moduleHelper.getNameForErrorTemplate(component.name);\n\t\tcomponent.errorTemplateProvider.registerCompiled(errorTemplateName, component.compiledErrorTemplate);\n\n\t\tcomponent.errorTemplate = {\n\t\t\trender: context => component.errorTemplateProvider.render(errorTemplateName, context)\n\t\t};\n\t},\n\n\t/**\n\t * Resolves valid template providers.\n\t * @param {ServiceLocator} locator Service locator that has providers registered.\n\t * @returns {Array<TemplateProvider>} List of template providers.\n\t */\n\tresolveTemplateProviders: locator => {\n\t\tconst eventBus = locator.resolve('eventBus');\n\t\ttry {\n\t\t\treturn locator\n\t\t\t\t.resolveAll('templateProvider')\n\t\t\t\t.filter(provider => {\n\t\t\t\t\tconst isValid = typeof (provider.getName) === 'function' &&\n\t\t\t\t\t\t\t\t\ttypeof (provider.registerCompiled) === 'function' &&\n\t\t\t\t\t\t\t\t\ttypeof (provider.render) === 'function';\n\t\t\t\t\tif (!isValid) {\n\t\t\t\t\t\teventBus.emit('warn', 'Template provider does not have required methods, skipping...');\n\t\t\t\t\t}\n\t\t\t\t\treturn isValid;\n\t\t\t\t});\n\t\t} catch (e) {\n\t\t\treturn [];\n\t\t}\n\t},\n\n\t/**\n\t * Resolves valid template providers by names.\n\t * @param {ServiceLocator} locator Service locator that has providers registered.\n\t * @returns {Object} Map of template providers by names.\n\t */\n\tresolveTemplateProvidersByNames: locator => {\n\t\treturn helper\n\t\t\t.resolveTemplateProviders(locator)\n\t\t\t.reduce((map, current) => {\n\t\t\t\tmap[current.getName()] = current;\n\t\t\t\treturn map;\n\t\t\t}, Object.create(null));\n\t}\n};\n\nmodule.exports = helper;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/helpers/loadHelper.js":"'use strict';\n\nconst path = require('path');\nconst fs = require('../promises/fs');\nconst moduleHelper = require('./moduleHelper');\n\nconst helper = {\n\n\t/**\n\t * Assigns template engines for component's templates.\n\t * @param {Object} component The component.\n\t * @param {Array<TemplateProvider>} providers Template providers to assign.\n\t * @private\n\t */\n\tassignTemplateProviders: (component, providers) => {\n\t\tcomponent.templateProvider = findTemplateProvider(providers, component.properties.template, component.templateSource);\n\t\tif (!component.templateProvider) {\n\t\t\tthrow new Error(`No template provider found that would be able to compile and render the template \"${component.properties.template}\" in \"${component.name}\" component`);\n\t\t}\n\n\t\tcomponent.errorTemplateProvider = null;\n\t\tif (typeof (component.errorTemplateSource) !== 'string') {\n\t\t\treturn;\n\t\t}\n\t\tcomponent.errorTemplateProvider = findTemplateProvider(providers, component.properties.errorTemplate, component.errorTemplateSource);\n\t\tif (!component.errorTemplateProvider) {\n\t\t\tthrow new Error(`No template provider found that would be able to compile and render the error template \"${component.properties.errorTemplate}\" in \"${component.name}\" component`);\n\t\t}\n\t},\n\n\t/**\n\t * Loads template sources from the files.\n\t * @param {Object} component The component.\n\t * @returns {Promise} The promise for finished work.\n\t */\n\tloadTemplateSources: component => {\n\t\tconst templateSourcePromise = Promise.resolve()\n\t\t\t.then(() => {\n\t\t\t\tconst templatePath = path.resolve(\n\t\t\t\t\tpath.dirname(component.path),\n\t\t\t\t\tcomponent.properties.template\n\t\t\t\t);\n\t\t\t\treturn fs.readFile(templatePath)\n\t\t\t\t\t.then(source => {\n\t\t\t\t\t\tcomponent.templateSource = source.toString();\n\t\t\t\t\t});\n\t\t\t});\n\n\t\tconst errorTemplateSourcePromise = Promise.resolve()\n\t\t\t.then(() => {\n\t\t\t\tcomponent.errorTemplateSource = null;\n\t\t\t\tconst relativePath = component.properties.errorTemplate;\n\t\t\t\tif (typeof (relativePath) !== 'string') {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst templatePath = path.resolve(\n\t\t\t\t\tpath.dirname(component.path),\n\t\t\t\t\trelativePath\n\t\t\t\t);\n\t\t\t\treturn fs.readFile(templatePath)\n\t\t\t\t\t.then(source => {\n\t\t\t\t\t\tcomponent.errorTemplateSource = source.toString();\n\t\t\t\t\t});\n\t\t\t});\n\n\t\treturn Promise.all([\n\t\t\ttemplateSourcePromise, errorTemplateSourcePromise\n\t\t]);\n\t},\n\n\t/**\n\t * Compiles template sources of the component.\n\t * @param {Object} component The component.\n\t * @returns {Promise} The promise for finished work.\n\t */\n\tcompileTemplates: component => {\n\t\tconst templateCompilePromise = Promise.resolve()\n\t\t\t.then(() => component.templateProvider.compile(component.templateSource, component.name));\n\n\t\tconst errorTemplateName = moduleHelper.getNameForErrorTemplate(component.name);\n\t\tconst errorTemplateCompilePromise = Promise.resolve()\n\t\t\t.then(() => {\n\t\t\t\tif (!component.errorTemplateSource) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn component.errorTemplateProvider.compile(component.errorTemplateSource, errorTemplateName);\n\t\t\t});\n\n\t\treturn Promise.all([\n\t\t\ttemplateCompilePromise,\n\t\t\terrorTemplateCompilePromise\n\t\t])\n\t\t\t.then(compiledTemplates => {\n\t\t\t\tcomponent.compiledTemplate = compiledTemplates[0];\n\t\t\t\tcomponent.compiledErrorTemplate = compiledTemplates[1] || null;\n\t\t\t});\n\t}\n};\n\n/**\n * Finds a template provider that would work with the template.\n * @param {Array<TemplateProviders>} providers List of template providers.\n * @param {string} filename Filename of the template.\n * @param {string} templateContent Content of the template file.\n * @returns {TemplateProvider|null} Template provider that supports the template.\n * @private\n */\nfunction findTemplateProvider(providers, filename, templateContent) {\n\tvar templateProvider = null;\n\tproviders.some(provider => {\n\t\tif (provider.isTemplateSupported(filename, templateContent)) {\n\t\t\ttemplateProvider = provider;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t});\n\treturn templateProvider;\n}\n\nmodule.exports = helper;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/helpers/requireHelper.js":"'use strict';\n\nconst path = require('path');\n\nmodule.exports = {\n\n\t/**\n\t * Creates an absolute path for the require call.\n\t * @param {string} filename The path to the file.\n\t * @returns {string} The absolute path to the file.\n\t */\n\tgetAbsoluteRequirePath: filename => `${process.cwd()}/${filename}`,\n\n\t/**\n\t * Clears the Node.js require cache for the specified key.\n\t * @param {string} key The cache key.\n\t */\n\tclearCacheKey: key => {\n\t\tkey = key || '';\n\t\tkey = key.replace(/\\\\|\\//g, path.sep);\n\t\tdelete require.cache[key];\n\t},\n\n\t/**\n\t * Gets a valid require path replacing all backslashes with slashes.\n\t * @param {string} path The path to the file.\n\t * @returns {string} The valid require path.\n\t */\n\tgetValidPath: path => typeof (path) === 'string' ?\n\t\tpath.replace(/\\\\/g, '\\\\\\\\') :\n\t\t''\n};\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/tokenizers/RouteParser.js":"'use strict';\n\nconst uriHelper = require('../helpers/uriHelper');\nconst catberryUri = require('catberry-uri');\nconst RouteParameterTokenizer = require('./RouteExpressionTokenizer');\nconst URI = catberryUri.URI;\n\nconst PATH_SUBSTITUTE_REG_EXP_SOURCE = '([^\\\\/\\\\\\\\]*)';\nconst SUBSTITUTE_REG_EXP_SOURCE = '(.*)';\nconst REG_EXP_ESCAPE = /[\\-\\[\\]\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/;\n\n/**\n * Implements the route parser for the server environment.\n */\nclass RouteParser {\n\n\t/**\n\t * Creates a new instance of the route parser.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * Current parameter string tokenizer.\n\t\t * @type {RouteParameterTokenizer}\n\t\t * @private\n\t\t */\n\t\tthis._tokenizer = new RouteParameterTokenizer();\n\t}\n\n\t/**\n\t * Creates route descriptor from the route expression.\n\t * @param {string} expression Route expression.\n\t * @returns {{expression: string, pathParameters: Array, queryParameters: Array, pathRegExpSource: string}}\n\t * Route descriptor.\n\t * @private\n\t */\n\tparseRouteExpression(expression) {\n\t\tconst expressionUri = new URI(expression);\n\t\tconst expressionPath = uriHelper.removeEndSlash(expressionUri.path);\n\n\t\t// finding required parameters in URI path for using the route\n\t\tconst pathParameters = this._parseExpressionParameters(expressionPath);\n\t\tconst matchExpression = buildMatcher(expressionPath, pathParameters, PATH_SUBSTITUTE_REG_EXP_SOURCE);\n\n\t\t// finding optional route parameters in query string\n\t\tconst queryParameters = [];\n\n\t\tif (expressionUri.query && expressionUri.query.values) {\n\t\t\tconst queryValues = expressionUri.query.values;\n\t\t\tObject.keys(queryValues)\n\t\t\t\t.forEach(name => {\n\t\t\t\t\tconst nameParameters = this._parseExpressionParameters(name);\n\t\t\t\t\tconst nameRegExpSource = buildMatcher(name, nameParameters, SUBSTITUTE_REG_EXP_SOURCE);\n\n\t\t\t\t\tconst valueParameters = queryValues[name] !== null ?\n\t\t\t\t\t\tthis._parseExpressionParameters(queryValues[name]) :\n\t\t\t\t\t\tnull;\n\t\t\t\t\tconst valueRegExpSource = valueParameters ?\n\t\t\t\t\t\tbuildMatcher(queryValues[name], valueParameters, SUBSTITUTE_REG_EXP_SOURCE) :\n\t\t\t\t\t\tnull;\n\n\t\t\t\t\tqueryParameters.push({\n\t\t\t\t\t\tnameExpression: name,\n\t\t\t\t\t\tvalueExpression: queryValues[name],\n\t\t\t\t\t\tnameParameters,\n\t\t\t\t\t\tvalueParameters,\n\t\t\t\t\t\tnameRegExpSource,\n\t\t\t\t\t\tvalueRegExpSource\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t}\n\n\t\treturn {\n\t\t\texpression,\n\t\t\tpathParameters,\n\t\t\tqueryParameters,\n\t\t\tpathRegExpSource: matchExpression\n\t\t};\n\t}\n\n\t/**\n\t * Parses parameters from a route expression.\n\t * @param {string} expression The route expression.\n\t * @returns {Array} List of parameter descriptors.\n\t * @private\n\t */\n\t_parseExpressionParameters(expression) {\n\t\tif (!expression) {\n\t\t\treturn [];\n\t\t}\n\t\tconst STATES = RouteParameterTokenizer.STATES;\n\n\t\tthis._tokenizer.setRouteExpression(expression);\n\n\t\tconst parameters = [];\n\t\tlet currentToken = RouteParameterTokenizer.STATES.NO;\n\t\tlet currentParameter = createParameterDescriptor();\n\t\tlet currentStores = Object.create(null);\n\n\t\tdo {\n\t\t\tcurrentToken = this._tokenizer.next();\n\n\t\t\tswitch (currentToken.state) {\n\t\t\t\tcase STATES.PARAMETER_START:\n\t\t\t\t\tcurrentParameter.start = currentToken.start;\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATES.PARAMETER_NAME:\n\t\t\t\t\tcurrentParameter.name = expression.substring(currentToken.start, currentToken.end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATES.STORE_LIST_ITEM:\n\t\t\t\t\tcurrentStores[expression.substring(currentToken.start, currentToken.end)] = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATES.TEXT:\n\t\t\t\t\tif (currentParameter.start >= 0) {\n\t\t\t\t\t\tcurrentParameter.end = currentToken.start;\n\t\t\t\t\t\tcurrentParameter.stores = Object.keys(currentStores);\n\t\t\t\t\t\tcurrentStores = Object.create(null);\n\t\t\t\t\t\tparameters.push(currentParameter);\n\t\t\t\t\t\tcurrentParameter = createParameterDescriptor();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATES.STORE_LIST_END:\n\t\t\t\t\tcurrentParameter.end = currentToken.end;\n\t\t\t\t\tcurrentParameter.stores = Object.keys(currentStores);\n\t\t\t\t\tcurrentStores = Object.create(null);\n\t\t\t\t\tparameters.push(currentParameter);\n\t\t\t\t\tcurrentParameter = createParameterDescriptor();\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATES.ILLEGAL:\n\t\t\t\t\tconst illegal = expression.substring(currentToken.start, currentToken.end);\n\t\t\t\t\tconst errorMessage = `Illegal character \"${illegal}\" at ${currentToken.start + 1} in route:\\n${expression}\\n${createSpaces(currentToken.start)}^`;\n\t\t\t\t\tthrow new Error(errorMessage);\n\t\t\t}\n\n\t\t} while (currentToken.state !== STATES.END);\n\n\t\treturn parameters;\n\t}\n}\n\n/**\n * Builds a regular expression for matching the actual URL parts\n * @param {string} expression Routing expression.\n * @param {Array} parameters List of extracted parameters.\n * @param {string} substitute Regular expression source for the\n * substitute of the parameter's value.\n * @returns {string} Regular expression source.\n */\nfunction buildMatcher(expression, parameters, substitute) {\n\tlet regExpSource = '^';\n\tlet nextParameterIndex = 0;\n\tlet nextParameter = parameters[nextParameterIndex];\n\n\tfor (let i = 0; i < expression.length; i++) {\n\n\t\tif (nextParameter && i === nextParameter.start) {\n\t\t\twhile (++i < nextParameter.end - 1) {\n\t\t\t\t// just skipping the parameter in the expression string\n\t\t\t}\n\t\t\tnextParameterIndex++;\n\t\t\tnextParameter = parameters[nextParameterIndex];\n\t\t\tregExpSource += substitute;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst current = expression[i];\n\n\t\tif (REG_EXP_ESCAPE.test(current)) {\n\t\t\tregExpSource += `\\\\${current}`;\n\t\t\tcontinue;\n\t\t}\n\n\t\tregExpSource += current;\n\t}\n\n\tregExpSource += '$';\n\treturn regExpSource;\n}\n\n/**\n * Creates a new parameter descriptor.\n * @returns {{start: number, end: number, name: null, stores: {}}}\n */\nfunction createParameterDescriptor() {\n\treturn {\n\t\tstart: -1,\n\t\tend: -1,\n\t\tname: null,\n\t\tstores: Object.create(null)\n\t};\n}\n\n/**\n * Creates a string with the specified number of spaces.\n * @param {number} count Number of spaces.\n * @returns {string} The string with specified number of spaces.\n */\nfunction createSpaces(count) {\n\tlet string = '';\n\n\twhile (count--) {\n\t\tstring += ' ';\n\t}\n\treturn string;\n}\n\nmodule.exports = RouteParser;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/helpers/uriHelper.js":"'use strict';\n\nconst PATH_END_SLASH_REG_EXP = /(.+)\\/($|\\?|#)/;\n\nmodule.exports = {\n\n\t/**\n\t * Removes a slash from the end of the URI path.\n\t * @param {string} uriPath The URI path.\n\t * @returns {string} The URI without a slash at the end.\n\t */\n\tremoveEndSlash(uriPath) {\n\t\tif (!uriPath || typeof (uriPath) !== 'string') {\n\t\t\treturn '';\n\t\t}\n\t\tif (uriPath === '/') {\n\t\t\treturn uriPath;\n\t\t}\n\t\treturn uriPath.replace(PATH_END_SLASH_REG_EXP, '$1$2');\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry-uri/index.js":"'use strict';\n\nmodule.exports = {\n\tURI: require('./lib/URI'),\n\tAuthority: require('./lib/Authority'),\n\tUserInfo: require('./lib/UserInfo'),\n\tQuery: require('./lib/Query')\n};\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry-uri/lib/URI.js":"'use strict';\n\nconst percentEncodingHelper = require('./percentEncodingHelper');\n\nconst Authority = require('./Authority');\nconst Query = require('./Query');\n\n// https://tools.ietf.org/html/rfc3986#appendix-B\nconst URI_PARSE_REGEXP = new RegExp(\n\t'^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?'\n\t);\n// https://tools.ietf.org/html/rfc3986#section-3.1\nconst SCHEME_REGEXP = /^[a-z]+[a-z\\d\\+\\.-]*$/i;\nconst ERROR_SCHEME = `URI scheme must satisfy expression ${SCHEME_REGEXP.toString()}`;\n\nclass URI {\n\n\t/**\n\t * Creates a new URI authority component.\n\t * @param {string?} Existing string.\n\t * @return {Authority} The authority component.\n\t */\n\tstatic createAuthority(string) {\n\t\treturn new Authority(string);\n\t}\n\n\t/**\n\t * Creates a new URI authority component.\n\t * @param {string?} Existing string.\n\t * @return {Authority} The authority component.\n\t */\n\tcreateAuthority(string) {\n\t\treturn URI.createAuthority(string);\n\t}\n\n\t/**\n\t * Creates a new URI user info component.\n\t * @param {string?} Existing string.\n\t * @return {UserInfo} The user info component.\n\t */\n\tstatic createUserInfo(string) {\n\t\treturn Authority.createUserInfo(string);\n\t}\n\n\t/**\n\t * Creates a new URI user info component.\n\t * @param {string?} Existing string.\n\t * @return {UserInfo} The user info component.\n\t */\n\tcreateUserInfo(string) {\n\t\treturn URI.createUserInfo(string);\n\t}\n\n\t/**\n\t * Creates a new URI query component.\n\t * @param {string?} Existing string.\n\t * @return {Query} The query component.\n\t */\n\tstatic createQuery(string) {\n\t\treturn new Query(string);\n\t}\n\n\t/**\n\t * Creates a new URI query component.\n\t * @param {string?} Existing string.\n\t * @return {Query} The query component.\n\t */\n\tcreateQuery(string) {\n\t\treturn URI.createQuery(string);\n\t}\n\n\t/**\n\t * Creates new instance of URI according to RFC 3986.\n\t * @param {string?} uriString URI string to parse components.\n\t */\n\tconstructor(uriString) {\n\n\t\t/**\n\t\t * Current URI scheme.\n\t\t * https://tools.ietf.org/html/rfc3986#section-3.1\n\t\t * @type {string}\n\t\t */\n\t\tthis.scheme = null;\n\n\t\t/**\n\t\t * Current URI authority.\n\t\t * https://tools.ietf.org/html/rfc3986#section-3.2\n\t\t * @type {Authority}\n\t\t */\n\t\tthis.authority = null;\n\n\t\t/**\n\t\t * Current URI path.\n\t\t * https://tools.ietf.org/html/rfc3986#section-3.3\n\t\t * @type {string}\n\t\t */\n\t\tthis.path = null;\n\n\t\t/**\n\t\t * Current URI query.\n\t\t * https://tools.ietf.org/html/rfc3986#section-3.4\n\t\t * @type {Query}\n\t\t */\n\t\tthis.query = null;\n\n\t\t/**\n\t\t * Current URI fragment.\n\t\t * https://tools.ietf.org/html/rfc3986#section-3.5\n\t\t * @type {string}\n\t\t */\n\t\tthis.fragment = null;\n\n\t\tif (typeof (uriString) !== 'string') {\n\t\t\turiString = '';\n\t\t}\n\n\t\t// https://tools.ietf.org/html/rfc3986#appendix-B\n\t\tconst matches = uriString.match(URI_PARSE_REGEXP);\n\n\t\tif (matches) {\n\t\t\tif (typeof (matches[2]) === 'string') {\n\t\t\t\tthis.scheme = percentEncodingHelper.decode(matches[2]);\n\t\t\t}\n\t\t\tif (typeof (matches[4]) === 'string') {\n\t\t\t\tthis.authority = URI.createAuthority(matches[4]);\n\t\t\t}\n\t\t\tif (typeof (matches[5]) === 'string') {\n\t\t\t\tthis.path = percentEncodingHelper.decodePath(matches[5]);\n\t\t\t}\n\t\t\tif (typeof (matches[7]) === 'string') {\n\t\t\t\tthis.query = URI.createQuery(matches[7]);\n\t\t\t}\n\t\t\tif (typeof (matches[9]) === 'string') {\n\t\t\t\tthis.fragment = percentEncodingHelper.decode(matches[9]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Converts a URI reference that might be relative to a given base URI\n\t * into the reference's target URI.\n\t * https://tools.ietf.org/html/rfc3986#section-5.2\n\t * @param {URI} baseUri Base URI.\n\t * @returns {URI} Resolved URI.\n\t */\n\tresolveRelative(baseUri) {\n\t\tif (!baseUri.scheme) {\n\t\t\tthrow new Error('Scheme component is required to be present in a base URI');\n\t\t}\n\n\t\treturn transformReference(baseUri, this);\n\t}\n\n\t/**\n\t * Clones current URI to a new object.\n\t * @returns {URI} New clone of current object.\n\t */\n\tclone() {\n\t\tconst uri = new URI();\n\n\t\tif (typeof (this.scheme) === 'string') {\n\t\t\turi.scheme = this.scheme;\n\t\t}\n\n\t\tif (this.authority) {\n\t\t\turi.authority = this.authority.clone();\n\t\t}\n\n\t\tif (typeof (this.path) === 'string') {\n\t\t\turi.path = this.path;\n\t\t}\n\n\t\tif (this.query) {\n\t\t\turi.query = this.query.clone();\n\t\t}\n\n\t\tif (typeof (this.fragment) === 'string') {\n\t\t\turi.fragment = this.fragment;\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Recomposes URI components to URI string,\n\t * https://tools.ietf.org/html/rfc3986#section-5.3\n\t * @returns {string} URI string.\n\t */\n\ttoString() {\n\t\tlet result = '';\n\n\t\tif (this.scheme !== undefined && this.scheme !== null) {\n\t\t\tconst scheme = String(this.scheme);\n\t\t\tif (!SCHEME_REGEXP.test(scheme)) {\n\t\t\t\tthrow new Error(ERROR_SCHEME);\n\t\t\t}\n\t\t\tresult += `${scheme}:`;\n\t\t}\n\n\t\tif (this.authority instanceof Authority) {\n\t\t\tresult += `//${this.authority.toString()}`;\n\t\t}\n\n\t\tconst path = this.path === undefined || this.path === null ?\n\t\t\t'' : String(this.path);\n\t\tresult += percentEncodingHelper.encodePath(path);\n\n\t\tif (this.query instanceof Query) {\n\t\t\tresult += `?${this.query.toString()}`;\n\t\t}\n\n\t\tif (this.fragment !== undefined && this.fragment !== null) {\n\t\t\tconst fragment = String(this.fragment);\n\t\t\tresult += `#${percentEncodingHelper.encodeFragment(fragment)}`;\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\n/**\n * Transforms reference for relative resolution.\n * Whole algorithm has been taken from\n * https://tools.ietf.org/html/rfc3986#section-5.2.2\n * @param {URI} baseUri Base URI for resolution.\n * @param {URI} referenceUri Reference URI to resolve.\n * @returns {URI} Components of target URI.\n */\nfunction transformReference(baseUri, referenceUri) {\n\n\t/* eslint complexity: [2, 13]*/\n\tconst targetUri = new URI('');\n\n\tif (referenceUri.scheme) {\n\t\ttargetUri.scheme = referenceUri.scheme;\n\t\ttargetUri.authority = referenceUri.authority ?\n\t\t\treferenceUri.authority.clone() : referenceUri.authority;\n\t\ttargetUri.path = removeDotSegments(referenceUri.path);\n\t\ttargetUri.query = referenceUri.query ?\n\t\t\treferenceUri.query.clone() : referenceUri.query;\n\t} else {\n\t\tif (referenceUri.authority) {\n\t\t\ttargetUri.authority = referenceUri.authority ?\n\t\t\t\treferenceUri.authority.clone() : referenceUri.authority;\n\t\t\ttargetUri.path = removeDotSegments(referenceUri.path);\n\t\t\ttargetUri.query = referenceUri.query ?\n\t\t\t\treferenceUri.query.clone() : referenceUri.query;\n\t\t} else {\n\t\t\tif (referenceUri.path === '') {\n\t\t\t\ttargetUri.path = baseUri.path;\n\t\t\t\tif (referenceUri.query) {\n\t\t\t\t\ttargetUri.query = referenceUri.query.clone();\n\t\t\t\t} else {\n\t\t\t\t\ttargetUri.query = baseUri.query ?\n\t\t\t\t\t\tbaseUri.query.clone() : baseUri.query;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (referenceUri.path[0] === '/') {\n\t\t\t\t\ttargetUri.path = removeDotSegments(referenceUri.path);\n\t\t\t\t} else {\n\t\t\t\t\ttargetUri.path = merge(baseUri, referenceUri);\n\t\t\t\t\ttargetUri.path = removeDotSegments(targetUri.path);\n\t\t\t\t}\n\t\t\t\ttargetUri.query = referenceUri.query ?\n\t\t\t\t\treferenceUri.query.clone() : referenceUri.query;\n\t\t\t}\n\t\t\ttargetUri.authority = baseUri.authority ?\n\t\t\t\tbaseUri.authority.clone() : baseUri.authority;\n\t\t}\n\t\ttargetUri.scheme = baseUri.scheme;\n\t}\n\n\ttargetUri.fragment = referenceUri.fragment;\n\treturn targetUri;\n}\n\n/**\n * Merges a relative-path reference with the path of the base URI.\n * https://tools.ietf.org/html/rfc3986#section-5.2.3\n * @param {URI} baseUri Components of base URI.\n * @param {URI} referenceUri Components of reference URI.\n * @returns {string} Merged path.\n */\nfunction merge(baseUri, referenceUri) {\n\tif (baseUri.authority && baseUri.path === '') {\n\t\treturn `/${referenceUri.path}`;\n\t}\n\n\tconst segmentsString = baseUri.path.indexOf('/') !== -1 ?\n\t\tbaseUri.path.replace(/\\/[^\\/]+$/, '/') : '';\n\n\treturn segmentsString + referenceUri.path;\n}\n\n/**\n * Removes dots segments from URI path.\n * https://tools.ietf.org/html/rfc3986#section-5.2.4\n * @param {string} uriPath URI path with possible dot segments.\n * @returns {string} URI path without dot segments.\n */\nfunction removeDotSegments(uriPath) {\n\tif (!uriPath) {\n\t\treturn '';\n\t}\n\n\tlet inputBuffer = uriPath;\n\tlet newBuffer = '';\n\tlet nextSegment = '';\n\tlet outputBuffer = '';\n\n\twhile (inputBuffer.length !== 0) {\n\n\t\t// If the input buffer begins with a prefix of \"../\" or \"./\",\n\t\t// then remove that prefix from the input buffer\n\t\tnewBuffer = inputBuffer.replace(/^\\.?\\.\\//, '');\n\t\tif (newBuffer !== inputBuffer) {\n\t\t\tinputBuffer = newBuffer;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// if the input buffer begins with a prefix of \"/./\" or \"/.\",\n\t\t// where \".\" is a complete path segment, then replace that\n\t\t// prefix with \"/\" in the input buffer\n\t\tnewBuffer = inputBuffer.replace(/^((\\/\\.\\/)|(\\/\\.$))/, '/');\n\t\tif (newBuffer !== inputBuffer) {\n\t\t\tinputBuffer = newBuffer;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// if the input buffer begins with a prefix of \"/../\" or \"/..\",\n\t\t// where \"..\" is a complete path segment, then replace that\n\t\t// prefix with \"/\" in the input buffer and remove the last\n\t\t// segment and its preceding \"/\" (if any) from the output\n\t\t// buffer\n\t\tnewBuffer = inputBuffer.replace(/^((\\/\\.\\.\\/)|(\\/\\.\\.$))/, '/');\n\t\tif (newBuffer !== inputBuffer) {\n\t\t\toutputBuffer = outputBuffer.replace(/\\/[^\\/]+$/, '');\n\t\t\tinputBuffer = newBuffer;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// if the input buffer consists only of \".\" or \"..\", then remove\n\t\t// that from the input buffer\n\t\tif (inputBuffer === '.' || inputBuffer === '..') {\n\t\t\tbreak;\n\t\t}\n\n\t\t// move the first path segment in the input buffer to the end of\n\t\t// the output buffer, including the initial \"/\" character (if\n\t\t// any) and any subsequent characters up to, but not including,\n\t\t// the next \"/\" character or the end of the input buffer\n\t\tnextSegment = /^\\/?[^\\/]*(\\/|$)/.exec(inputBuffer)[0];\n\t\tnextSegment = nextSegment.replace(/([^\\/])(\\/$)/, '$1');\n\t\tinputBuffer = inputBuffer.substring(nextSegment.length);\n\t\toutputBuffer += nextSegment;\n\t}\n\n\treturn outputBuffer;\n}\n\nmodule.exports = URI;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry-uri/lib/percentEncodingHelper.js":"'use strict';\n\n// https://tools.ietf.org/html/rfc3986#section-2.1\n\nmodule.exports = {\n\t// \\uD800-\\uDBFF \\uDC00-\\uDFFF\n\t// surrogates pairs like emoji we should ignore\n\t/**\n\t * Encodes authority user information sub-component according to RFC 3986.\n\t * @param {string} string Component to encode.\n\t * @returns {string} Encoded component.\n\t */\n\tencodeUserInfoSubComponent(string) {\n\t\treturn string.replace(\n\t\t\t// https://tools.ietf.org/html/rfc3986#section-3.2.1\n\t\t\t/[^\\w\\.~\\-!\\$&'\\(\\)\\*\\+,;=\\uD800-\\uDBFF\\uDC00-\\uDFFF]/g,\n\t\t\tencodeURIComponent\n\t\t);\n\t},\n\n\t/**\n\t * Encodes authority host component according to RFC 3986.\n\t * @param {string} string Component to encode.\n\t * @returns {string} Encoded component.\n\t */\n\tencodeHost(string) {\n\t\treturn string.replace(\n\t\t\t// https://tools.ietf.org/html/rfc3986#section-3.2.2\n\t\t\t/[^\\w\\.~\\-!\\$&'\\(\\)\\*\\+,;=:\\[\\]\\uD800-\\uDBFF\\uDC00-\\uDFFF]/g,\n\t\t\tencodeURIComponent\n\t\t);\n\t},\n\n\t/**\n\t * Encodes URI path component according to RFC 3986.\n\t * @param {string} string Component to encode.\n\t * @returns {string} Encoded component.\n\t */\n\tencodePath(string) {\n\t\treturn string.split(/%2f/i)\n\t\t\t.map(part => {\n\t\t\t\treturn part.replace(\n\t\t\t\t\t// https://tools.ietf.org/html/rfc3986#section-3.3\n\t\t\t\t\t/[^\\w\\.~\\-!\\$&'\\(\\)\\*\\+,;=:@\\/\\uD800-\\uDBFF\\uDC00-\\uDFFF]/g,\n\t\t\t\t\tencodeURIComponent\n\t\t\t\t);\n\t\t\t})\n\t\t\t.reduce((prev, current) => !prev ? current : `${prev}%2F${current}`, '');\n\t},\n\n\t/**\n\t * Encodes query sub-component according to RFC 3986.\n\t * @param {string} string Component to encode.\n\t * @returns {string} Encoded component.\n\t */\n\tencodeQuerySubComponent(string) {\n\t\treturn string.replace(\n\t\t\t// https://tools.ietf.org/html/rfc3986#section-3.4\n\t\t\t/[^\\w\\.~\\-!\\$'\\(\\)\\*,;:@\\/\\?\\uD800-\\uDBFF\\uDC00-\\uDFFF]/g,\n\t\t\tencodeURIComponent\n\t\t);\n\t},\n\n\t/**\n\t * Encodes URI fragment component according to RFC 3986.\n\t * @param {string} string Component to encode.\n\t * @returns {string} Encoded component.\n\t */\n\tencodeFragment(string) {\n\t\treturn string.replace(\n\t\t\t// https://tools.ietf.org/html/rfc3986#section-3.5\n\t\t\t/[^\\w\\.~\\-!\\$&'\\(\\)\\*\\+,;=:@\\/\\?\\uD800-\\uDBFF\\uDC00-\\uDFFF]/g,\n\t\t\tencodeURIComponent\n\t\t);\n\t},\n\n\t/**\n\t * Decodes percent encoded component.\n\t * @param {string} string Component to decode.\n\t * @returns {string} Decoded component.\n\t */\n\tdecode(string) {\n\t\treturn decodeURIComponent(string);\n\t},\n\n\t/**\n\t * Decodes percent encoded path component.\n\t * @param {string} string Component to decode.\n\t * @returns {string} Decoded path component.\n\t */\n\tdecodePath(string) {\n\t\treturn string.split(/%2f/i)\n\t\t\t.map(decodeURIComponent)\n\t\t\t.reduce((prev, current) => !prev ? current : `${prev}%2F${current}`, '');\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry-uri/lib/Authority.js":"'use strict';\n\nconst UserInfo = require('./UserInfo');\nconst percentEncodingHelper = require('./percentEncodingHelper');\n\nconst PORT_REGEXP = /^\\d+$/;\nconst ERROR_PORT = `URI authority port must satisfy expression ${PORT_REGEXP.toString()}`;\n\nclass Authority {\n\n\t/**\n\t * Creates a new URI user info component.\n\t * @param {string?} Existing string.\n\t * @return {UserInfo} The user info component.\n\t */\n\tstatic createUserInfo(string) {\n\t\treturn new UserInfo(string);\n\t}\n\n\t/**\n\t * Creates a new URI user info component.\n\t * @param {string?} Existing string.\n\t * @return {UserInfo} The user info component.\n\t */\n\tcreateUserInfo(string) {\n\t\treturn Authority.createUserInfo(string);\n\t}\n\n\t/**\n\t * Creates new instance of URI authority component parser.\n\t * https://tools.ietf.org/html/rfc3986#section-3.2\n\t * @param {string?} authorityString URI authority component string.\n\t */\n\tconstructor(authorityString) {\n\n\t\t/**\n\t\t * Current user information.\n\t\t * https://tools.ietf.org/html/rfc3986#section-3.2.1\n\t\t * @type {UserInfo}\n\t\t */\n\t\tthis.userInfo = null;\n\n\t\t/**\n\t\t * Current port.\n\t\t * https://tools.ietf.org/html/rfc3986#section-3.2.3\n\t\t * @type {string}\n\t\t */\n\t\tthis.port = null;\n\n\t\t/**\n\t\t * Current host.\n\t\t * https://tools.ietf.org/html/rfc3986#section-3.2.2\n\t\t * @type {string}\n\t\t */\n\t\tthis.host = null;\n\n\t\tif (typeof (authorityString) === 'string' && authorityString.length > 0) {\n\t\t\tconst firstAtIndex = authorityString.indexOf('@');\n\t\t\tif (firstAtIndex !== -1) {\n\t\t\t\tconst userInfoString = authorityString.substring(0, firstAtIndex);\n\t\t\t\tthis.userInfo = new UserInfo(userInfoString);\n\t\t\t\tauthorityString = authorityString.substring(firstAtIndex + 1);\n\t\t\t}\n\n\t\t\tconst lastColonIndex = authorityString.lastIndexOf(':');\n\t\t\tif (lastColonIndex !== -1) {\n\t\t\t\tconst portString = authorityString.substring(lastColonIndex + 1);\n\t\t\t\tif (lastColonIndex === authorityString.length - 1) {\n\t\t\t\t\tthis.port = '';\n\t\t\t\t\tauthorityString = authorityString.substring(0, lastColonIndex);\n\t\t\t\t} else if (PORT_REGEXP.test(portString)) {\n\t\t\t\t\tthis.port = portString;\n\t\t\t\t\tauthorityString = authorityString.substring(0, lastColonIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.host = percentEncodingHelper.decode(authorityString);\n\t\t}\n\t}\n\n\t/**\n\t * Clones current authority.\n\t * @returns {Authority} New clone of current object.\n\t */\n\tclone() {\n\t\tconst authority = new Authority();\n\t\tif (this.userInfo) {\n\t\t\tauthority.userInfo = this.userInfo.clone();\n\t\t}\n\t\tif (typeof (this.host) === 'string') {\n\t\t\tauthority.host = this.host;\n\t\t}\n\t\tif (typeof (this.port) === 'string') {\n\t\t\tauthority.port = this.port;\n\t\t}\n\t\treturn authority;\n\t}\n\n\t/**\n\t * Recombine all authority components into authority string.\n\t * @returns {string} Authority component string.\n\t */\n\ttoString() {\n\t\tlet result = '';\n\t\tif (this.userInfo instanceof UserInfo) {\n\t\t\tresult += `${this.userInfo.toString()}@`;\n\t\t}\n\t\tif (this.host !== undefined && this.host !== null) {\n\t\t\tconst host = String(this.host);\n\t\t\tresult += percentEncodingHelper.encodeHost(host);\n\t\t}\n\t\tif (this.port !== undefined && this.port !== null) {\n\t\t\tconst port = String(this.port);\n\t\t\tif (port.length > 0 && !PORT_REGEXP.test(port)) {\n\t\t\t\tthrow new Error(ERROR_PORT);\n\t\t\t}\n\t\t\tresult += `:${port}`;\n\t\t}\n\t\treturn result;\n\t}\n}\n\nmodule.exports = Authority;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry-uri/lib/UserInfo.js":"'use strict';\n\nconst percentEncodingHelper = require('./percentEncodingHelper');\n\nclass UserInfo {\n\n\t/**\n\t * Creates new instance of user information component parser.\n\t * https://tools.ietf.org/html/rfc3986#section-3.2.1\n\t * @param {string?} userInfoString User information component string.\n\t */\n\tconstructor(userInfoString) {\n\n\t\t/**\n\t\t * Current user component.\n\t\t * @type {string}\n\t\t */\n\t\tthis.user = null;\n\n\t\t/**\n\t\t * Current password.\n\t\t * @type {string}\n\t\t */\n\t\tthis.password = null;\n\n\t\tif (typeof (userInfoString) === 'string' && userInfoString.length > 0) {\n\t\t\tconst parts = userInfoString.split(':');\n\t\t\tif (typeof (parts[0]) === 'string') {\n\t\t\t\tthis.user = percentEncodingHelper.decode(parts[0]);\n\t\t\t}\n\t\t\tif (typeof (parts[1]) === 'string') {\n\t\t\t\tthis.password = percentEncodingHelper.decode(parts[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clones current user information.\n\t * @returns {UserInfo} New clone of current object.\n\t */\n\tclone() {\n\t\tconst userInfo = new UserInfo();\n\t\tif (typeof (this.user) === 'string') {\n\t\t\tuserInfo.user = this.user;\n\t\t}\n\t\tif (typeof (this.password) === 'string') {\n\t\t\tuserInfo.password = this.password;\n\t\t}\n\t\treturn userInfo;\n\t}\n\n\t/**\n\t * Recombines user information components to userInfo string.\n\t * @returns {string} User information component string.\n\t */\n\ttoString() {\n\t\tlet result = '';\n\t\tif (this.user !== undefined && this.user !== null) {\n\t\t\tconst user = String(this.user);\n\t\t\tresult += percentEncodingHelper\n\t\t\t\t.encodeUserInfoSubComponent(user);\n\t\t}\n\t\tif (this.password !== undefined && this.password !== null) {\n\t\t\tconst password = String(this.password);\n\t\t\tresult += `:${percentEncodingHelper.encodeUserInfoSubComponent(password)}`;\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nmodule.exports = UserInfo;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry-uri/lib/Query.js":"'use strict';\n\nconst percentEncodingHelper = require('./percentEncodingHelper');\n\nclass Query {\n\n\t/**\n\t * Creates new instance of URI query component parser.\n\t * https://tools.ietf.org/html/rfc3986#section-3.4\n\t * @param {string?} queryString URI query component string.\n\t */\n\tconstructor(queryString) {\n\n\t\t/**\n\t\t * Current set of values of query.\n\t\t * @type {Object}\n\t\t */\n\t\tthis.values = null;\n\n\t\tif (typeof (queryString) === 'string') {\n\t\t\tthis.values = {};\n\n\t\t\tqueryString\n\t\t\t\t.split('&')\n\t\t\t\t.forEach(pair => {\n\t\t\t\t\tconst parts = pair.split('=');\n\t\t\t\t\tconst key = percentEncodingHelper.decode(parts[0]);\n\t\t\t\t\tif (!key) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (key in this.values &&\n\t\t\t\t\t\t!(this.values[key] instanceof Array)) {\n\t\t\t\t\t\tthis.values[key] = [this.values[key]];\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = typeof (parts[1]) === 'string' ?\n\t\t\t\t\t\tpercentEncodingHelper.decode(parts[1]) : null;\n\n\t\t\t\t\tif (this.values[key] instanceof Array) {\n\t\t\t\t\t\tthis.values[key].push(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.values[key] = value;\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\t}\n\t}\n\n\t/**\n\t * Clones current query to a new object.\n\t * @returns {Query} New clone of current object.\n\t */\n\tclone() {\n\t\tconst query = new Query();\n\t\tif (this.values) {\n\t\t\tquery.values = {};\n\t\t\tObject.keys(this.values)\n\t\t\t\t.forEach(key => {\n\t\t\t\t\tquery.values[key] = this.values[key];\n\t\t\t\t}, this);\n\t\t}\n\t\treturn query;\n\t}\n\n\t/**\n\t * Converts current set of query values to string.\n\t * @returns {string} Query component string.\n\t */\n\ttoString() {\n\t\tif (!this.values) {\n\t\t\treturn '';\n\t\t}\n\n\t\tlet queryString = '';\n\t\tObject.keys(this.values)\n\t\t\t.forEach(key => {\n\t\t\t\tconst values = this.values[key] instanceof Array ?\n\t\t\t\t\tthis.values[key] : [this.values[key]];\n\n\t\t\t\tvalues.forEach(value => {\n\t\t\t\t\tqueryString += `&${percentEncodingHelper.encodeQuerySubComponent(key)}`;\n\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvalue = String(value);\n\t\t\t\t\tqueryString += `=${percentEncodingHelper.encodeQuerySubComponent(value)}`;\n\t\t\t\t});\n\t\t\t}, this);\n\n\t\treturn queryString.replace(/^&/, '');\n\t}\n}\n\nmodule.exports = Query;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/tokenizers/RouteExpressionTokenizer.js":"'use strict';\n\nconst STATES = {\n\tILLEGAL: -1,\n\tNO: 0,\n\tPARAMETER_START: 1,\n\tPARAMETER_NAME: 2,\n\tSTORE_LIST_START: 3,\n\tSTORE_LIST_ITEM: 4,\n\tSTORE_LIST_COMMA: 5,\n\tSTORE_LIST_END: 6,\n\tTEXT: 7,\n\tEND: 8\n};\nObject.freeze(STATES);\n\nconst PARAMETER_FIRST_REGEXP = /[$A-Z_]/i;\nconst PARAMETER_TAIL_REGEXP = /[$\\w]/;\nconst STORE_NAME_REGEXP = /[\\w$\\/-]/;\nconst WHITESPACE_REGEXP = /\\s/;\n\nclass RouteExpressionTokenizer {\n\n\t/**\n\t * Creates a new instance of the route expression tokenizer.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * Current source code of the route rule.\n\t\t * @type {string}\n\t\t * @private\n\t\t */\n\t\tthis._source = '';\n\n\t\t/**\n\t\t * Current index in the route expression.\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._currentIndex = 0;\n\n\t\t/**\n\t\t * Current token end index in the route expression.\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._currentEnd = 0;\n\n\t\t/**\n\t\t * Current state.\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._currentState = STATES.NO;\n\t}\n\n\t/**\n\t * Gets the state constants map.\n\t */\n\tstatic get STATES() {\n\t\treturn STATES;\n\t}\n\n\t/**\n\t * Sets the route expression string to tokenize.\n\t * @param {string} routeExpression Route expression string.\n\t */\n\tsetRouteExpression(routeExpression) {\n\t\tthis._source = routeExpression;\n\t\tthis._currentIndex = 0;\n\t\tthis._currentEnd = 0;\n\t\tthis._currentState = STATES.NO;\n\t}\n\n\t/**\n\t * Gets a next token in source.\n\t * @returns {{state: (number), start: number, end: number}}\n\t */\n\t/* eslint complexity: 0 */\n\tnext() {\n\t\tconst start = this._currentIndex;\n\t\tconst state = this._currentState;\n\n\t\tswitch (this._currentState) {\n\t\t\tcase STATES.PARAMETER_START:\n\t\t\t\tthis.parameterStartState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.PARAMETER_NAME:\n\t\t\t\tthis.parameterNameState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.STORE_LIST_START:\n\t\t\t\tthis.storeListStartState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.STORE_LIST_ITEM:\n\t\t\t\tthis.storeListItemState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.STORE_LIST_COMMA:\n\t\t\t\tthis.storeListCommaState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.STORE_LIST_END:\n\t\t\t\tthis.storeListEndState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.TEXT:\n\t\t\t\tthis.textState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.ILLEGAL:\n\t\t\tcase STATES.END:\n\t\t\t\treturn {\n\t\t\t\t\tstate,\n\t\t\t\t\tstart,\n\t\t\t\t\tend: start + 1\n\t\t\t\t};\n\t\t\tdefault:\n\t\t\t\tif (this._currentIndex === this._source.length) {\n\t\t\t\t\tthis._currentState = STATES.END;\n\t\t\t\t} else if (this._source[start] === ':') {\n\t\t\t\t\tthis._currentState = STATES.PARAMETER_START;\n\t\t\t\t} else {\n\t\t\t\t\tthis._currentState = STATES.TEXT;\n\t\t\t\t}\n\t\t\t\treturn this.next();\n\t\t}\n\n\t\treturn {\n\t\t\tstate,\n\t\t\tstart,\n\t\t\tend: this._currentEnd\n\t\t};\n\t}\n\n\t/**\n\t * Describes the PARAMETER_START state.\n\t */\n\tparameterStartState() {\n\t\tthis.toNextChar();\n\n\t\tif (this._currentIndex < this._source.length &&\n\t\t\tPARAMETER_FIRST_REGEXP.test(this._source[this._currentIndex])) {\n\t\t\tthis._currentState = STATES.PARAMETER_NAME;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n\n\t/**\n\t * Describes the PARAMETER_NAME state.\n\t */\n\tparameterNameState() {\n\t\tthis.toNextChar();\n\n\t\twhile (this._currentIndex < this._source.length &&\n\t\t\t\t\tPARAMETER_TAIL_REGEXP.test(this._source[this._currentIndex])) {\n\t\t\tthis.toNextChar();\n\t\t}\n\n\t\tif (this._source[this._currentIndex] === '[') {\n\t\t\tthis._currentState = STATES.STORE_LIST_START;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._currentIndex === this._source.length) {\n\t\t\tthis._currentState = STATES.END;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentState = STATES.TEXT;\n\t}\n\n\t/**\n\t * Describes the STORE_LIST_START state.\n\t */\n\tstoreListStartState() {\n\t\tthis.toNextChar();\n\t\tthis.skipWhitespace();\n\n\t\tif (this._source[this._currentIndex] === ']') {\n\t\t\tthis._currentState = STATES.STORE_LIST_END;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._currentIndex < this._source.length &&\n\t\t\tSTORE_NAME_REGEXP.test(this._source[this._currentIndex])) {\n\t\t\tthis._currentState = STATES.STORE_LIST_ITEM;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n\n\t/**\n\t * Describes the STORE_LIST_ITEM state.\n\t */\n\tstoreListItemState() {\n\t\tthis.toNextChar();\n\n\t\twhile (this._currentIndex < this._source.length &&\n\t\t\t\t\tSTORE_NAME_REGEXP.test(this._source[this._currentIndex])) {\n\t\t\tthis.toNextChar();\n\t\t}\n\n\t\tthis.skipWhitespace();\n\n\t\tif (this._source[this._currentIndex] === ',') {\n\t\t\tthis._currentState = STATES.STORE_LIST_COMMA;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._source[this._currentIndex] === ']') {\n\t\t\tthis._currentState = STATES.STORE_LIST_END;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n\n\t/**\n\t * Describes the STORE_LIST_COMMA state.\n\t */\n\tstoreListCommaState() {\n\t\tthis.toNextChar();\n\t\tthis.skipWhitespace();\n\n\t\tif (this._currentIndex < this._source.length &&\n\t\t\tSTORE_NAME_REGEXP.test(this._source[this._currentIndex])) {\n\t\t\tthis._currentState = STATES.STORE_LIST_ITEM;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n\n\t/**\n\t * Describes the STORE_LIST_END state.\n\t */\n\tstoreListEndState() {\n\t\tthis.toNextChar();\n\n\t\tif (this._currentIndex === this._source.length) {\n\t\t\tthis._currentState = STATES.END;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentState = STATES.TEXT;\n\t}\n\n\t/**\n\t * Describes the TEXT state.\n\t */\n\ttextState() {\n\t\tthis.toNextChar();\n\n\t\twhile (this._currentIndex < this._source.length &&\n\t\t\t\tthis._source[this._currentIndex] !== ':') {\n\t\t\tthis.toNextChar();\n\t\t}\n\n\t\tif (this._source[this._currentIndex] === ':') {\n\t\t\tthis._currentState = STATES.PARAMETER_START;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentState = STATES.END;\n\t}\n\n\t/**\n\t * Skips all whitespace characters.\n\t */\n\tskipWhitespace() {\n\t\twhile (this._currentIndex < this._source.length &&\n\t\t\t\t\tWHITESPACE_REGEXP.test(this._source[this._currentIndex])) {\n\t\t\tthis._currentIndex++;\n\t\t}\n\t}\n\n\t/**\n\t * Moved pointer to the next char.\n\t */\n\ttoNextChar() {\n\t\tthis._currentIndex++;\n\t\tthis._currentEnd = this._currentIndex;\n\t}\n}\n\nmodule.exports = RouteExpressionTokenizer;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/finders/StoreFinder.js":"'use strict';\n\nconst path = require('path');\nconst requireHelper = require('../helpers/requireHelper');\nconst events = require('events');\nconst chokidar = require('chokidar');\nconst glob = require('glob');\n\nconst DEFAULT_STORES_ROOT = 'catberry_stores';\nconst DEFAULT_STORES_GLOB = '**/*.js';\n\nconst CHOKIDAR_OPTIONS = {\n\tignoreInitial: true,\n\tcwd: process.cwd(),\n\tignorePermissionErrors: true\n};\n\n/**\n * Implements the store finder module.\n */\nclass StoreFinder extends events.EventEmitter {\n\n\t/**\n\t * Creates a new instance of the store finder.\n\t * @param {ServiceLocator} locator The service locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\t\tsuper();\n\n\t\tconst config = locator.resolve('config');\n\n\t\t/**\n\t\t * Current event bus.\n\t\t * @type {EventEmitter}\n\t\t * @private\n\t\t */\n\t\tthis._eventBus = locator.resolve('eventBus');\n\n\t\t/**\n\t\t * Current folder with Catberry stores.\n\t\t * @type {string}\n\t\t */\n\t\tthis._storesDirectory = requireHelper.getValidPath(\n\t\t\tconfig.storesDirectory || DEFAULT_STORES_ROOT\n\t\t);\n\n\t\t/**\n\t\t * Current glob for the store files.\n\t\t * @type {string}\n\t\t */\n\t\tthis._storesGlobExpression = requireHelper.getValidPath(path.join(\n\t\t\tthis._storesDirectory, config.storesGlob || DEFAULT_STORES_GLOB\n\t\t));\n\n\t\t/**\n\t\t * Current Promise for the ready state.\n\t\t * @type {Promise}\n\t\t * @private\n\t\t */\n\t\tthis._readyPromise = null;\n\n\t\t/**\n\t\t * Current Map of last found stores by their names.\n\t\t * @type {Map}\n\t\t * @private\n\t\t */\n\t\tthis._foundStoresByNames = null;\n\t}\n\n\t/**\n\t * Finds all the stores.\n\t * @returns {Promise<Map>} The Promise for Map of found stores by names.\n\t */\n\tfind() {\n\t\tif (this._foundStoresByNames) {\n\t\t\treturn Promise.resolve(this._foundStoresByNames);\n\t\t}\n\n\t\tthis._foundStoresByNames = Object.create(null);\n\n\t\treturn new Promise((fulfill, reject) => {\n\t\t\tconst storeFilesGlob = new glob.Glob(this._storesGlobExpression, {\n\t\t\t\tnosort: true,\n\t\t\t\tsilent: true,\n\t\t\t\tnodir: true\n\t\t\t});\n\n\t\t\tstoreFilesGlob\n\t\t\t\t.on('match', match => {\n\t\t\t\t\tconst storeDescriptor = this._createStoreDescriptor(match);\n\t\t\t\t\tthis._foundStoresByNames[storeDescriptor.name] = storeDescriptor;\n\t\t\t\t\tthis._eventBus.emit('storeFound', storeDescriptor);\n\t\t\t\t})\n\t\t\t\t.on('error', error => reject(error))\n\t\t\t\t.on('end', fulfill);\n\t\t})\n\t\t.then(() => this._foundStoresByNames);\n\t}\n\n\t/**\n\t * Watches the components for changing.\n\t */\n\twatch() {\n\t\tif (this._readyPromise) {\n\t\t\treturn this._readyPromise;\n\t\t}\n\n\t\tconst fileWatcher = chokidar.watch(\n\t\t\tthis._storesGlobExpression, CHOKIDAR_OPTIONS\n\t\t);\n\t\tconst fileWatcherPromise = new Promise((fulfill, reject) => {\n\t\t\tfileWatcher\n\t\t\t\t.once('ready', () => fulfill())\n\t\t\t\t.once('error', error => reject(error));\n\t\t});\n\n\t\tthis._readyPromise = fileWatcherPromise\n\t\t\t.then(() => {\n\n\t\t\t\tfileWatcher\n\t\t\t\t\t.on('error', error => this._eventBus.emit('error', error))\n\t\t\t\t\t.on('add', filename => {\n\t\t\t\t\t\tconst store = this._createStoreDescriptor(filename);\n\t\t\t\t\t\tthis._foundStoresByNames[store.name] = store;\n\t\t\t\t\t\tthis.emit('add', store);\n\t\t\t\t\t})\n\t\t\t\t\t.on('change', filename => {\n\t\t\t\t\t\tconst store = this._createStoreDescriptor(filename);\n\t\t\t\t\t\tthis._foundStoresByNames[store.name] = store;\n\t\t\t\t\t\tthis.emit('change', store);\n\t\t\t\t\t})\n\t\t\t\t\t.on('unlink', filename => {\n\t\t\t\t\t\tconst store = this._createStoreDescriptor(filename);\n\t\t\t\t\t\tdelete this._foundStoresByNames[store.name];\n\t\t\t\t\t\tthis.emit('unlink', store);\n\t\t\t\t\t});\n\t\t\t\tthis.emit('watchReady');\n\t\t\t\treturn fileWatcher;\n\t\t\t});\n\n\t\treturn this._readyPromise;\n\t}\n\n\t/**\n\t * Closes watcher.\n\t * @returns {Promise} Promise of closed watcher.\n\t */\n\tcloseWatch() {\n\t\tif (this._readyPromise) {\n\t\t\tconst promise = this._readyPromise;\n\n\t\t\tthis._readyPromise = null;\n\n\t\t\treturn promise.then(watcher => watcher.close());\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Creates a descriptor for the found store.\n\t * @param {string} filename The store's filename.\n\t * @returns {{name: string, path: string}} The store descriptor.\n\t * @private\n\t */\n\t_createStoreDescriptor(filename) {\n\t\tconst relative = path.relative(this._storesDirectory, filename);\n\t\tconst basename = path.basename(relative, path.extname(relative));\n\t\tconst directory = path.dirname(relative);\n\t\tconst storeName = directory !== '.' ?\n\t\t\tpath.dirname(relative) + path.sep + basename : basename;\n\n\t\treturn {\n\t\t\tname: storeName.replace(/\\\\/g, '/'), // normalize name for windows\n\t\t\tpath: path.relative(process.cwd(), filename)\n\t\t};\n\t}\n}\n\nmodule.exports = StoreFinder;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/finders/ComponentFinder.js":"'use strict';\n\nconst path = require('path');\nconst requireHelper = require('../helpers/requireHelper');\nconst moduleHelper = require('../helpers/moduleHelper');\nconst chokidar = require('chokidar');\nconst events = require('events');\nconst glob = require('glob');\n\nconst CHOKIDAR_OPTIONS = {\n\tignoreInitial: true,\n\tuseFsEvents: false,\n\tcwd: process.cwd(),\n\tignorePermissionErrors: true\n};\n\nconst COMPONENTS_DEFAULT_GLOB = [\n\t'catberry_components/**/cat-component.json',\n\t'node_modules/*/cat-component.json'\n];\nconst COMPONENT_NAME_REGEXP = /^[\\w-]+$/i;\n\n/**\n * Implements the component finder module.\n */\nclass ComponentFinder extends events.EventEmitter {\n\n\t/**\n\t * Creates a new instance of the component finder.\n\t * @param {ServiceLocator} locator The Service Locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Current event bus.\n\t\t * @type {EventEmitter}\n\t\t * @private\n\t\t */\n\t\tthis._eventBus = locator.resolve('eventBus');\n\n\t\t/**\n\t\t * Current file watcher.\n\t\t * @type {FileWatcher}\n\t\t * @private\n\t\t */\n\t\tthis._fileWatcher = null;\n\n\t\t/**\n\t\t * Current set of last found components by their names.\n\t\t * @type {Map}\n\t\t * @private\n\t\t */\n\t\tthis._foundComponentsByNames = null;\n\n\t\t/**\n\t\t * Current Map of last found components by their directories.\n\t\t * @type {Map}\n\t\t * @private\n\t\t */\n\t\tthis._foundComponentsByDirs = null;\n\n\t\t/**\n\t\t * Current Promise for the ready state.\n\t\t * @type {Promise}\n\t\t * @private\n\t\t */\n\t\tthis._readyPromise = null;\n\n\t\t/**\n\t\t * Current components' glob.\n\t\t * @type {string}\n\t\t * @private\n\t\t */\n\t\tthis._componentsGlob = COMPONENTS_DEFAULT_GLOB;\n\n\t\tconst componentsGlob = locator.resolve('config').componentsGlob;\n\t\tif (typeof (componentsGlob) === 'string') {\n\t\t\tthis._componentsGlob = [componentsGlob];\n\t\t} else if (Array.isArray(componentsGlob)) {\n\t\t\tconst areStrings = componentsGlob\n\t\t\t\t.every(expression => typeof (expression) === 'string');\n\n\t\t\tif (areStrings) {\n\t\t\t\tthis._componentsGlob = componentsGlob;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Finds all the components.\n\t * @returns {Promise<Map>} Promise for Map of found components by their names.\n\t */\n\tfind() {\n\t\tif (this._foundComponentsByNames) {\n\t\t\treturn Promise.resolve(this._foundComponentsByNames);\n\t\t}\n\n\t\tthis._foundComponentsByNames = Object.create(null);\n\t\tthis._foundComponentsByDirs = Object.create(null);\n\n\t\tconst cache = {};\n\t\tconst symlinks = {};\n\t\tconst statCache = {};\n\n\t\tconst promises = this._componentsGlob\n\t\t\t.map(expression => new Promise((fulfill, reject) => {\n\t\t\t\tconst componentFilesGlob = new glob.Glob(expression, {\n\t\t\t\t\tnosort: true,\n\t\t\t\t\tsilent: true,\n\t\t\t\t\tnodir: true,\n\t\t\t\t\tcache,\n\t\t\t\t\tstatCache,\n\t\t\t\t\tsymlinks\n\t\t\t\t});\n\n\t\t\t\tcomponentFilesGlob\n\t\t\t\t\t.on('match', match => {\n\t\t\t\t\t\tconst componentDescriptor =\n\t\t\t\t\t\t\tthis._createComponentDescriptor(match);\n\n\t\t\t\t\t\tthis._addComponent(componentDescriptor);\n\t\t\t\t\t\tthis._eventBus.emit(\n\t\t\t\t\t\t\t'componentFound', componentDescriptor\n\t\t\t\t\t\t);\n\t\t\t\t\t})\n\t\t\t\t\t.on('error', error => reject(error))\n\t\t\t\t\t.on('end', fulfill);\n\t\t\t}));\n\n\t\treturn Promise\n\t\t\t.all(promises)\n\t\t\t.then(() => this._foundComponentsByNames);\n\t}\n\n\t/**\n\t * Watches the components for changing.\n\t *\n\t * @return {Promise} Promise of ready watchers.\n\t */\n\twatch() {\n\t\tif (this._readyPromise) {\n\t\t\treturn this._readyPromise;\n\t\t}\n\n\t\tconst fileWatcher = chokidar.watch(Object.keys(this._foundComponentsByDirs), CHOKIDAR_OPTIONS);\n\t\tconst fileWatcherReadyPromise = new Promise((fulfill, reject) => {\n\t\t\tfileWatcher\n\t\t\t\t.once('ready', () => fulfill())\n\t\t\t\t.once('error', error => reject(error));\n\t\t});\n\t\t// watch cat-component.json files\n\t\tconst componentJsonWatcher = chokidar.watch(this._componentsGlob, CHOKIDAR_OPTIONS);\n\t\tconst componentJsonReadyPromise = new Promise((fulfill, reject) => {\n\t\t\tcomponentJsonWatcher\n\t\t\t\t.once('ready', () => fulfill())\n\t\t\t\t.once('error', error => reject(error));\n\t\t});\n\n\t\tthis._readyPromise = Promise\n\t\t\t.all([fileWatcherReadyPromise, componentJsonReadyPromise])\n\t\t\t.then(() => {\n\t\t\t\tthis._fileWatcher = fileWatcher;\n\t\t\t\tfileWatcher\n\t\t\t\t\t.on('error', error => this._eventBus.emit('error', error))\n\t\t\t\t// component's directory is changed\n\t\t\t\t\t.on('change', filename => {\n\t\t\t\t\t\tconst component = this._recognizeComponent(filename);\n\t\t\t\t\t\tif (!component || component.path === filename) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst changeArgs = {\n\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\tcomponent\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// logic file is changed\n\t\t\t\t\t\tconst relativeLogic = this._getRelativeForComponent(\n\t\t\t\t\t\t\tcomponent.path, component.properties.logic\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (filename === relativeLogic) {\n\t\t\t\t\t\t\tthis.emit('changeLogic', component);\n\t\t\t\t\t\t\tthis.emit('change', changeArgs);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// template files are changed\n\t\t\t\t\t\tconst relativeTemplate = this._getRelativeForComponent(\n\t\t\t\t\t\t\tcomponent.path, component.properties.template\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst relativeErrorTemplate =\n\t\t\t\t\t\t\t\t\t\ttypeof (component.properties.errorTemplate) === 'string' ?\n\t\t\t\t\t\t\t\t\t\tthis._getRelativeForComponent(\n\t\t\t\t\t\t\t\t\t\t\tcomponent.path, component.properties.errorTemplate\n\t\t\t\t\t\t\t\t\t\t) : null;\n\n\t\t\t\t\t\tif (filename === relativeTemplate ||\n\t\t\t\t\t\t\t\tfilename === relativeErrorTemplate) {\n\t\t\t\t\t\t\tthis.emit('changeTemplates', component);\n\t\t\t\t\t\t\tthis.emit('change', changeArgs);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.emit('change', changeArgs);\n\t\t\t\t\t})\n\t\t\t\t\t.on('unlink', filename => {\n\t\t\t\t\t\tconst component = this._recognizeComponent(filename);\n\n\t\t\t\t\t\tif (!component || component.path === filename) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.emit('change', {filename, component});\n\t\t\t\t\t})\n\t\t\t\t\t.on('add', filename => {\n\t\t\t\t\t\tconst component = this._recognizeComponent(filename);\n\t\t\t\t\t\tif (!component || component.path === filename) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.emit('change', {filename, component});\n\t\t\t\t\t});\n\n\t\t\t\tcomponentJsonWatcher\n\t\t\t\t\t.on('error', error => this._eventBus.emit('error', error))\n\t\t\t\t// add new component\n\t\t\t\t\t.on('add', filename => {\n\t\t\t\t\t\tconst newComponent = this._createComponentDescriptor(filename);\n\t\t\t\t\t\tthis._addComponent(newComponent);\n\t\t\t\t\t\tthis.emit('add', newComponent);\n\t\t\t\t\t})\n\t\t\t\t// change cat-component.json of the found component\n\t\t\t\t\t.on('change', filename => {\n\t\t\t\t\t\tconst component = this._recognizeComponent(filename);\n\t\t\t\t\t\tif (!component) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst newComponent = this._createComponentDescriptor(component.path);\n\n\t\t\t\t\t\t// because component name could be changed\n\t\t\t\t\t\tthis._removeComponent(component);\n\t\t\t\t\t\tthis.emit('unlink', component);\n\n\t\t\t\t\t\tthis._addComponent(newComponent);\n\t\t\t\t\t\tthis.emit('add', newComponent);\n\t\t\t\t\t})\n\t\t\t\t// unlink found component\n\t\t\t\t\t.on('unlink', filename => {\n\t\t\t\t\t\tconst component = this._recognizeComponent(filename);\n\t\t\t\t\t\tif (!component) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._removeComponent(component);\n\t\t\t\t\t\tthis.emit('unlink', component);\n\t\t\t\t\t});\n\n\t\t\t\tthis.emit('watchReady');\n\t\t\t\treturn [fileWatcher, componentJsonWatcher];\n\t\t\t});\n\n\t\treturn this._readyPromise;\n\t}\n\n\t/**\n\t * Close watchers\n\t *\n\t * @return {Promise} Promise of closed watchers.\n\t */\n\tcloseWatch() {\n\t\tthis._fileWatcher = null;\n\t\tif (this._readyPromise) {\n\t\t\tconst promise = this._readyPromise;\n\n\t\t\tthis._readyPromise = null;\n\n\t\t\treturn promise.then(watchers => watchers.forEach(watcher => watcher.close()));\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Creates a descriptor for a found component.\n\t * @param {string} filename The component's filename.\n\t * @returns {{name: string, path: string, properties: Object}|null} The found\n\t * component's descriptor.\n\t * @private\n\t */\n\t_createComponentDescriptor(filename) {\n\t\tif (!filename) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst absolutePath = requireHelper.getAbsoluteRequirePath(filename);\n\t\trequireHelper.clearCacheKey(absolutePath);\n\n\t\tvar properties;\n\t\ttry {\n\t\t\tproperties = require(absolutePath);\n\t\t} catch (e) {\n\t\t\tthis._eventBus.emit('error', e);\n\t\t}\n\n\t\tif (!properties) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst componentName = (properties.name ||\n\t\t\tpath.basename(path.dirname(filename))).toLowerCase();\n\n\t\tif (!COMPONENT_NAME_REGEXP.test(componentName)) {\n\t\t\tthis._eventBus.emit('warn',\n\t\t\t\t`Component name \"${componentName}\" is incorrect (${COMPONENT_NAME_REGEXP.toString()}), skipping...`\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (typeof (properties.logic) !== 'string') {\n\t\t\tproperties.logic = moduleHelper.DEFAULT_LOGIC_FILENAME;\n\t\t}\n\n\t\tif (typeof (properties.template) !== 'string') {\n\t\t\tthis._eventBus.emit('warn',\n\t\t\t\t`\"template\" is a required field for component \"${properties.name}\" at ${properties.path}, skipping...`\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tname: componentName,\n\t\t\tproperties,\n\t\t\tpath: path.relative(process.cwd(), filename)\n\t\t};\n\t}\n\n\t/**\n\t * Recognizes a component by a path to its internal file.\n\t * @param {string} filename The filename of the internal file of the component.\n\t * @returns {{name: string, path: string, properties: Object}|null} The found\n\t * component's descriptor.\n\t * @private\n\t */\n\t_recognizeComponent(filename) {\n\t\tvar current = filename;\n\t\tvar component = null;\n\n\t\twhile (current !== '.') {\n\t\t\tif (current in this._foundComponentsByDirs) {\n\t\t\t\tcomponent = this._foundComponentsByDirs[current];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent = path.dirname(current);\n\t\t}\n\t\treturn component;\n\t}\n\n\t/**\n\t * Removes a found component.\n\t * @param {{name: string, path: string, properties: Object}?} component The found\n\t * component's descriptor to remove.\n\t * @private\n\t */\n\t_removeComponent(component) {\n\t\tconst dirName = path.dirname(component.path);\n\t\tconst absolutePath = requireHelper.getAbsoluteRequirePath(component.path);\n\n\t\trequireHelper.clearCacheKey(absolutePath);\n\n\t\tdelete this._foundComponentsByNames[component.name];\n\t\tdelete this._foundComponentsByDirs[dirName];\n\n\t\tif (this._fileWatcher) {\n\t\t\tthis._fileWatcher.unwatch(dirName);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a found component.\n\t * @param {{name: string, path: string, properties: Object}?} component The found\n\t * component's descriptor to add.\n\t * @private\n\t */\n\t_addComponent(component) {\n\t\tif (!component) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (component.name in this._foundComponentsByNames) {\n\t\t\tconst existedComponent = this._foundComponentsByNames[component.name];\n\t\t\tthis._eventBus.emit('warn',\n\t\t\t\t`Component ${component.path} has the same name as ${existedComponent.path} (${component.name}), skipping...`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tconst dirName = path.dirname(component.path);\n\t\tthis._foundComponentsByNames[component.name] = component;\n\t\tthis._foundComponentsByDirs[dirName] = component;\n\n\t\tif (this._fileWatcher) {\n\t\t\tthis._fileWatcher.add(dirName);\n\t\t}\n\t}\n\n\t/**\n\t * Gets a component's inner path which is relative to CWD.\n\t * @param {string} componentPath The path to the component.\n\t * @param {string} innerPath The path inside the component.\n\t * @returns {string} The path which is relative to CWD.\n\t */\n\t_getRelativeForComponent(componentPath, innerPath) {\n\t\treturn path.relative(\n\t\t\tprocess.cwd(), path.normalize(\n\t\t\t\tpath.join(path.dirname(componentPath), innerPath)\n\t\t\t)\n\t\t);\n\t}\n}\n\nmodule.exports = ComponentFinder;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/base/BootstrapperBase.js":"'use strict';\n\nconst moduleHelper = require('../helpers/moduleHelper');\nconst StateProvider = require('../providers/StateProvider');\nconst StoreLoader = require('../loaders/StoreLoader');\nconst ComponentLoader = require('../loaders/ComponentLoader');\nconst DocumentRenderer = require('../DocumentRenderer');\nconst RequestRouter = require('../RequestRouter');\nconst ModuleApiProviderBase = require('../base/ModuleApiProviderBase');\nconst ContextFactory = require('../ContextFactory');\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Implements the basic bootstrapper class\n * for both server and browser environments.\n */\nclass BootstrapperBase {\n\n\t/**\n\t * Creates a new instance of the basic Catberry bootstrapper.\n\t * @param {Function} catberryConstructor Constructor\n\t * of the Catberry's main module.\n\t */\n\tconstructor(catberryConstructor) {\n\n\t\t/**\n\t\t * Current constructor of the Catberry's main module.\n\t\t * @type {Function}\n\t\t * @private\n\t\t */\n\t\tthis._catberryConstructor = catberryConstructor;\n\t}\n\n\t/**\n\t * Creates a new full-configured instance of the Catberry application.\n\t * @param {Object?} configObject The configuration object.\n\t * @returns {Catberry} The Catberry application instance.\n\t */\n\tcreate(configObject) {\n\t\tconst currentConfig = configObject || {};\n\t\tconst catberry = new this._catberryConstructor();\n\n\t\tthis.configure(currentConfig, catberry.locator);\n\t\tcatberry.events = new ModuleApiProviderBase(catberry.locator);\n\t\treturn catberry;\n\t}\n\n\t/**\n\t * Configures a locator with all required type registrations.\n\t * @param {Object} configObject The configuration object.\n\t * @param {ServiceLocator} locator The Service locator to configure.\n\t */\n\tconfigure(configObject, locator) {\n\t\tconst eventBus = new EventEmitter();\n\t\teventBus.setMaxListeners(0);\n\t\tlocator.registerInstance('eventBus', eventBus);\n\t\tlocator.registerInstance('config', configObject);\n\t\tlocator.register('stateProvider', StateProvider, true);\n\t\tlocator.register('contextFactory', ContextFactory, true);\n\t\tlocator.register('storeLoader', StoreLoader, true);\n\t\tlocator.register('componentLoader', ComponentLoader, true);\n\t\tlocator.register('documentRenderer', DocumentRenderer, true);\n\t\tlocator.register('requestRouter', RequestRouter, true);\n\t}\n}\n\nmodule.exports = BootstrapperBase;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/providers/StateProvider.js":"'use strict';\n\nconst StateProviderBase = require('../base/StateProviderBase');\nconst RouteParser = require('../tokenizers/RouteParser');\n\n/**\n * Implements the state provider for the server environment.\n */\nclass StateProvider extends StateProviderBase {\n\n\t/**\n\t * Gets a list of route descriptors.\n\t * @param {ServiceLocator} serviceLocator The Service locator\n\t * for getting route definitions.\n\t * @returns {Array} The list of URI mappers.\n\t * @private\n\t */\n\t_getRouteDescriptors(serviceLocator) {\n\t\tconst descriptors = [];\n\t\tconst parser = new RouteParser();\n\n\t\tvar routeDefinitions;\n\n\t\ttry {\n\t\t\trouteDefinitions = serviceLocator.resolveAll('routeDefinition');\n\t\t} catch (e) {\n\t\t\trouteDefinitions = [];\n\t\t}\n\n\t\trouteDefinitions\n\t\t\t.forEach(route => {\n\t\t\t\t// just colon-parametrized string\n\t\t\t\tif (typeof (route) === 'string') {\n\t\t\t\t\tdescriptors.push(parser.parseRouteExpression(route));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// extended colon-parametrized mapper\n\t\t\t\tif (typeof (route) === 'object' &&\n\t\t\t\t\t\ttypeof (route.expression) === 'string') {\n\n\t\t\t\t\tconst descriptor = parser.parseRouteExpression(route.expression);\n\n\t\t\t\t\tif (typeof (route.name) === 'string') {\n\t\t\t\t\t\tdescriptor.name = route.name;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (route.map instanceof Function) {\n\t\t\t\t\t\tdescriptor.map = route.map;\n\t\t\t\t\t}\n\n\t\t\t\t\tdescriptors.push(descriptor);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// regular expression mapper\n\t\t\t\tif (typeof (route) === 'object' &&\n\t\t\t\t\t(route.expression instanceof RegExp) &&\n\t\t\t\t\t(route.map instanceof Function)) {\n\t\t\t\t\tdescriptors.push(route);\n\t\t\t\t}\n\t\t\t});\n\t\treturn descriptors;\n\t}\n}\n\nmodule.exports = StateProvider;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/base/StateProviderBase.js":"'use strict';\n\nconst uriHelper = require('../helpers/uriHelper');\nconst catberryUri = require('catberry-uri');\nconst URI = catberryUri.URI;\n\n/**\n * Implements the state provider for the server environment.\n */\nclass StateProviderBase {\n\n\t/**\n\t * Create a new instance of the state provider.\n\t * @param {ServiceLocator} locator Service locator for resolving URI mappers.\n\t */\n\tconstructor(locator) {\n\n\t\t/**\n\t\t * Current set of named routes.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._namedRoutes = Object.create(null);\n\n\t\t/**\n\t\t * Current route descriptors.\n\t\t */\n\t\tthis._routeDescriptors = this._getRouteDescriptors(locator);\n\t\tthis._routeDescriptors.forEach(descriptor => {\n\t\t\tthis._restoreRegularExpressions(descriptor);\n\t\t\tif (typeof (descriptor.name) === 'string') {\n\t\t\t\tthis._namedRoutes[descriptor.name] = descriptor;\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * Current list of URI mappers.\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._uriMappers = this._getUriMappers();\n\t}\n\n\t/**\n\t * Gets a state by the specified location URI.\n\t * @param {URI} uri The URI location.\n\t * @returns {Object|null} The state object.\n\t */\n\tgetStateByUri(uri) {\n\t\tif (this._uriMappers.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\turi = uri.clone();\n\t\turi.scheme = null;\n\t\turi.authority = null;\n\t\turi.fragment = null;\n\t\turi.path = uriHelper.removeEndSlash(uri.path);\n\n\t\tconst state = this._mapState(uri);\n\t\tif (!state) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// make state object immutable\n\t\tObject.keys(state).forEach(storeName => Object.freeze(state[storeName]));\n\t\tObject.freeze(state);\n\n\t\treturn state;\n\t}\n\n\t/**\n\t * Gets a URI path string for the named route using specified parameters.\n\t * @param {string} name The name of the route.\n\t * @param {Object} values The set of parameter values for the route.\n\t * @returns {string} URI path string.\n\t */\n\tgetRouteURI(name, values) {\n\t\tvalues = values || Object.create(null);\n\t\tconst descriptor = this._namedRoutes[name];\n\t\tif (!descriptor) {\n\t\t\tthrow new Error(`There is no such route called \"${name}\"`);\n\t\t}\n\n\t\tconst uri = new URI(descriptor.expression);\n\n\t\t// set value to URI path parameters first\n\t\tif (descriptor.pathParameters.length > 0) {\n\t\t\turi.path = setParameterValues(\n\t\t\t\turi.path, descriptor.pathParameters, values,\n\t\t\t\t(parameter, value) => encodeURIComponent(defaultParameterValueProcessor(parameter, value))\n\t\t\t);\n\t\t}\n\n\t\t// trying to set query string parameters if they exist\n\t\tif (descriptor.queryParameters.length > 0) {\n\t\t\tconst queryValues = Object.create(null);\n\n\t\t\tdescriptor.queryParameters.forEach(queryParameter => {\n\t\t\t\tconst name = setParameterValues(\n\t\t\t\t\tqueryParameter.nameExpression, queryParameter.nameParameters, values\n\t\t\t\t);\n\n\t\t\t\t// if there is no name means there is no query parameter at all\n\t\t\t\tif (!name) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// if there are no parameter values it means the query\n\t\t\t\t// parameter does not have value\n\t\t\t\tif (!queryParameter.valueParameters) {\n\t\t\t\t\tqueryValues[name] = null;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// if there are no route parameters in the query parameter's value\n\t\t\t\t// that means it has a static value\n\t\t\t\tif (queryParameter.valueParameters.length === 0) {\n\t\t\t\t\tqueryValues[name] = queryParameter.valueExpression;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst firstParameterName = queryParameter.valueParameters[0].name;\n\t\t\t\tconst firstParameterValue = values[firstParameterName];\n\t\t\t\t// if there is only one parameter in query value and\n\t\t\t\t// the specified parameter's value is an array\n\t\t\t\tif (queryParameter.valueParameters.length === 1 && Array.isArray(firstParameterValue)) {\n\t\t\t\t\tqueryValues[name] = [];\n\t\t\t\t\tfirstParameterValue.forEach(value => {\n\t\t\t\t\t\tconst valuesObject = Object.create(null);\n\t\t\t\t\t\tvaluesObject[firstParameterName] = value;\n\t\t\t\t\t\tconst queryValueString = setParameterValues(\n\t\t\t\t\t\t\tqueryParameter.valueExpression, queryParameter.valueParameters, valuesObject\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (queryValueString.length > 0) {\n\t\t\t\t\t\t\tqueryValues[name].push(queryValueString);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst queryValueString = setParameterValues(\n\t\t\t\t\tqueryParameter.valueExpression, queryParameter.valueParameters, values\n\t\t\t\t);\n\t\t\t\tif (queryValueString.length > 0) {\n\t\t\t\t\tqueryValues[name] = queryValueString;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (Object.keys(queryValues).length === 0) {\n\t\t\t\turi.query = null;\n\t\t\t} else {\n\t\t\t\turi.query.values = queryValues;\n\t\t\t}\n\t\t}\n\n\t\treturn uri.toString();\n\t}\n\n\t/**\n\t * Maps the state.\n\t * @param {URI} uri URI that describes the state.\n\t * @returns {Object|null} The state from URI.\n\t * @private\n\t */\n\t_mapState(uri) {\n\t\tlet state = null;\n\t\tthis._uriMappers.some(mapper => {\n\t\t\tstate = mapper(uri);\n\t\t\treturn Boolean(state);\n\t\t});\n\n\t\treturn state;\n\t}\n\n\t/**\n\t * Gets a list of URI mappers.\n\t * @returns {Array} The list of URI mappers.\n\t * @private\n\t */\n\t_getUriMappers() {\n\t\treturn this._routeDescriptors.map(descriptor => {\n\t\t\tif (descriptor.expression instanceof RegExp) {\n\t\t\t\treturn uri => descriptor.expression.test(uri.toString()) ? descriptor.map(uri) : null;\n\t\t\t}\n\n\t\t\tconst extractor = this._createParameterExtractor(descriptor);\n\t\t\tif (descriptor.map instanceof Function) {\n\t\t\t\treturn uri => {\n\t\t\t\t\tconst state = extractor(uri);\n\t\t\t\t\treturn state ? descriptor.map(state) : state;\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn extractor;\n\t\t});\n\t}\n\n\t/**\n\t * Gets a list of route descriptors.\n\t * @param {ServiceLocator} serviceLocator The Service locator\n\t * for getting route definitions.\n\t * @returns {Array} The list of route descriptors.\n\t * @protected\n\t * @abstract\n\t */\n\t_getRouteDescriptors(serviceLocator) {\n\n\t}\n\n\t/**\n\t * Restores all the regular expressions from their sources.\n\t * @param {Object} descriptor The route descriptor.\n\t * @private\n\t */\n\t_restoreRegularExpressions(descriptor) {\n\n\t\t// because the object is converted to JSON we have to store the\n\t\t// regular expressions as their sources\n\t\tif (descriptor.pathRegExpSource) {\n\t\t\tdescriptor.pathRegExp = new RegExp(descriptor.pathRegExpSource, 'i');\n\t\t}\n\t\tif (!descriptor.queryParameters) {\n\t\t\treturn;\n\t\t}\n\t\tdescriptor.queryParameters.forEach(parameter => {\n\t\t\tparameter.nameRegExp = new RegExp(parameter.nameRegExpSource, 'i');\n\t\t\tif (parameter.valueRegExpSource) {\n\t\t\t\tparameter.valueRegExp = new RegExp(parameter.valueRegExpSource, 'i');\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Creates a function that extracts parameters from the URI.\n\t * @param {Object} routeDescriptor Route descriptor.\n\t * @returns {function} Function\n\t * @private\n\t */\n\t_createParameterExtractor(routeDescriptor) {\n\t\tconst pathRegExp = new RegExp(routeDescriptor.pathRegExpSource);\n\t\treturn uri => {\n\t\t\tconst pathMatches = uri.path.match(pathRegExp);\n\t\t\tif (!pathMatches) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst state = Object.create(null);\n\t\t\tconst pathParameterValues = pathMatches.slice(1);\n\n\t\t\tsetStateValues(state, pathParameterValues, routeDescriptor.pathParameters);\n\n\t\t\tif (uri.query && uri.query.values) {\n\t\t\t\tsetQueryParameters(state, uri.query.values, routeDescriptor);\n\t\t\t}\n\n\t\t\treturn state;\n\t\t};\n\t}\n}\n\n/**\n * Sets parameter values to the state using parameter and store names.\n * @param {Object} state Current state object.\n * @param {Array} values Current values.\n * @param {Array} parameters List of parameter descriptors.\n */\nfunction setStateValues(state, values, parameters) {\n\tvalues.forEach((value, index) => {\n\t\tconst parameter = parameters[index];\n\t\tparameter.stores.forEach(storeName => {\n\t\t\tif (!(storeName in state)) {\n\t\t\t\tstate[storeName] = Object.create(null);\n\t\t\t}\n\n\t\t\t// if URI has several values for the same parameter it turns to an array\n\t\t\tif (parameter.name in state[storeName]) {\n\t\t\t\tif (Array.isArray(state[storeName][parameter.name])) {\n\t\t\t\t\tstate[storeName][parameter.name].push(value);\n\t\t\t\t} else {\n\t\t\t\t\tstate[storeName][parameter.name] = [state[storeName][parameter.name], value];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstate[storeName][parameter.name] = value;\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Sets query parameters to the state.\n * @param {Object} state Current state object.\n * @param {Object} queryValues URI query parameters.\n * @param {Object} routeDescriptor Current route descriptor.\n */\nfunction setQueryParameters(state, queryValues, routeDescriptor) {\n\tObject.keys(queryValues)\n\t\t.forEach(name => {\n\t\t\tconst value = queryValues[name];\n\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue.forEach(item => {\n\t\t\t\t\tconst subValues = Object.create(null);\n\t\t\t\t\tsubValues[name] = item;\n\t\t\t\t\tsetQueryParameters(state, subValues, routeDescriptor);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst isValue = typeof (value) === 'string';\n\n\t\t\tlet queryNameMatches = null;\n\t\t\tlet queryValueMatches = null;\n\t\t\tlet routeParameter = null;\n\n\t\t\trouteDescriptor.queryParameters.some(parameter => {\n\t\t\t\tqueryNameMatches = name.match(parameter.nameRegExp);\n\n\t\t\t\tif (isValue && parameter.valueRegExp) {\n\t\t\t\t\tqueryValueMatches = value.match(parameter.valueRegExp);\n\t\t\t\t}\n\n\t\t\t\tif (queryNameMatches) {\n\t\t\t\t\trouteParameter = parameter;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\n\t\t\tif (!routeParameter) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsetStateValues(state, queryNameMatches.slice(1), routeParameter.nameParameters);\n\n\t\t\tif (!queryValueMatches) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsetStateValues(state, queryValueMatches.slice(1), routeParameter.valueParameters);\n\t\t});\n}\n\n/**\n * Sets parameter values to a route expression.\n * @param {string} expression The route expression.\n * @param {Array} parameters Array of route parameters.\n * @param {Object} values Dictionary of route parameter values.\n * @param {function?} preProcessor Value preprocessor\n * @returns {string} String with substituted values.\n * @private\n */\nfunction setParameterValues(expression, parameters, values, preProcessor) {\n\tif (!parameters || parameters.length === 0) {\n\t\treturn expression;\n\t}\n\n\tpreProcessor = preProcessor || defaultParameterValueProcessor;\n\n\t// apply values for parameters in the URI path\n\tlet nextParameterIndex = 0;\n\tlet nextParameter = parameters[nextParameterIndex];\n\tlet result = '';\n\n\tfor (let i = 0; i < expression.length; i++) {\n\t\tif (nextParameter && i === nextParameter.start) {\n\t\t\tresult += preProcessor(nextParameter, values[nextParameter.name]);\n\t\t\twhile (++i < nextParameter.end - 1) {\n\t\t\t\t// just skipping the parameter in the expression string\n\t\t\t}\n\t\t\tnextParameterIndex++;\n\t\t\tnextParameter = parameters[nextParameterIndex];\n\t\t\tcontinue;\n\t\t}\n\t\tresult += expression[i];\n\t}\n\treturn result;\n}\n\n/**\n * Processes parameter value by default.\n * @param {Object} parameter Parameter descriptor.\n * @param {*} value Parameter's value.\n * @returns {string} Processed value.\n */\nfunction defaultParameterValueProcessor(parameter, value) {\n\tif (Array.isArray(value)) {\n\t\tthrow new Error(`Array value is not supported for the parameter \"${parameter.name}\"`);\n\t}\n\treturn value === undefined ? '' : String(value);\n}\n\nmodule.exports = StateProviderBase;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/loaders/StoreLoader.js":"'use strict';\n\nconst requireHelper = require('../helpers/requireHelper');\nconst path = require('path');\nconst LoaderBase = require('../base/LoaderBase');\n\n/**\n * Implements the component Loader class for server environment.\n */\nclass StoreLoader extends LoaderBase {\n\n\t/**\n\t * Creates a new instance of the store loader.\n\t * @param {ServiceLocator} locator The service locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\t\tvar storeTransforms;\n\t\ttry {\n\t\t\tstoreTransforms = locator.resolveAll('storeTransform');\n\t\t} catch (e) {\n\t\t\tstoreTransforms = [];\n\t\t}\n\t\tsuper(locator, storeTransforms);\n\n\t\t/**\n\t\t * Current event bus.\n\t\t * @type {EventEmitter}\n\t\t * @private\n\t\t */\n\t\tthis._eventBus = locator.resolve('eventBus');\n\n\t\t/**\n\t\t * Current store finder.\n\t\t * @type {StoreFinder}\n\t\t * @private\n\t\t */\n\t\tthis._storeFinder = locator.resolve('storeFinder');\n\n\t\t/**\n\t\t * Current release flag.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._isRelease = Boolean(locator.resolve('config').isRelease);\n\n\t\t/**\n\t\t * Current map of loaded stores by their names.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadedStores = null;\n\t}\n\n\t/**\n\t * Loads all stores into the memory.\n\t * @returns {Promise<Object>} The promise for a map of the loaded stores.\n\t */\n\tload() {\n\t\tif (this._loadedStores) {\n\t\t\treturn Promise.resolve(this._loadedStores);\n\t\t}\n\n\t\tconst result = Object.create(null);\n\n\t\treturn this._storeFinder.find()\n\t\t\t.then(details => {\n\t\t\t\tconst storePromises = Object.keys(details)\n\t\t\t\t\t.map(storeName => this._getStore(details[storeName]));\n\t\t\t\treturn Promise.all(storePromises);\n\t\t\t})\n\t\t\t.then(stores => {\n\t\t\t\tstores.forEach(store => {\n\t\t\t\t\tif (!store || typeof (store) !== 'object') {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[store.name] = store;\n\t\t\t\t});\n\n\t\t\t\tthis._loadedStores = result;\n\n\t\t\t\tif (!this._isRelease) {\n\t\t\t\t\tthis._eventBus.emit('info', 'Watching stores for changes...');\n\t\t\t\t\tthis._storeFinder.watch();\n\t\t\t\t\tthis._handleChanges();\n\t\t\t\t}\n\n\t\t\t\tthis._eventBus.emit('allStoresLoaded', result);\n\t\t\t\treturn this._loadedStores;\n\t\t\t});\n\t}\n\n\t/**\n\t * Gets current map of stores by their names.\n\t * @returns {Object} The map of stores by their names.\n\t */\n\tgetStoresByNames() {\n\t\treturn this._loadedStores || Object.create(null);\n\t}\n\n\t/**\n\t * Gets a store object by the found store details.\n\t * @param {Object} storeDetails The found details.\n\t * @returns {Object} The store object.\n\t * @private\n\t */\n\t_getStore(storeDetails) {\n\t\tvar constructor;\n\t\ttry {\n\t\t\tconstructor = require(requireHelper.getAbsoluteRequirePath(storeDetails.path));\n\t\t} catch (e) {\n\t\t\tthis._eventBus.emit('error', e);\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\n\t\tif (typeof (constructor) !== 'function') {\n\t\t\tconst errorMessage = `Store's file ${storeDetails.path} should export a constructor function or a class`;\n\t\t\tthis._eventBus.emit('error', new Error(errorMessage));\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\n\t\tconst result = Object.create(storeDetails);\n\t\tresult.constructor = constructor;\n\n\t\treturn this._applyTransforms(result)\n\t\t\t.then(transformed => {\n\t\t\t\tif (!transformed) {\n\t\t\t\t\tthrow new Error(`Transformation for the \"${storeDetails.name}\" store returned a bad result`);\n\t\t\t\t}\n\t\t\t\tthis._eventBus.emit('storeLoaded', transformed);\n\t\t\t\treturn transformed;\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\tthis._eventBus.emit('error', error);\n\t\t\t\treturn null;\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles changes while watching.\n\t * @private\n\t */\n\t_handleChanges() {\n\t\tconst loadStore = storeDetails => {\n\t\t\tthis._getStore(storeDetails)\n\t\t\t\t.then(store => {\n\t\t\t\t\tthis._loadedStores[storeDetails.name] = store;\n\t\t\t\t});\n\t\t};\n\n\t\tthis._storeFinder\n\t\t\t.on('add', storeDetails => {\n\t\t\t\tthis._eventBus.emit('info', `Store \"${storeDetails.path}\" has been added, initializing...`);\n\t\t\t\trequireHelper.clearCacheKey(requireHelper.getAbsoluteRequirePath(storeDetails.path));\n\t\t\t\tloadStore(storeDetails);\n\t\t\t})\n\t\t\t.on('change', storeDetails => {\n\t\t\t\tthis._eventBus.emit('info', `Store \"${storeDetails.path}\" has been changed, reinitializing...`);\n\t\t\t\trequireHelper.clearCacheKey(requireHelper.getAbsoluteRequirePath(storeDetails.path));\n\t\t\t\tloadStore(storeDetails);\n\t\t\t})\n\t\t\t.on('unlink', storeDetails => {\n\t\t\t\tthis._eventBus.emit('info', `Store \"${storeDetails.path}\" has been unlinked, removing...`);\n\t\t\t\trequireHelper.clearCacheKey(requireHelper.getAbsoluteRequirePath(storeDetails.path));\n\t\t\t\tdelete this._loadedStores[storeDetails.name];\n\t\t\t});\n\t}\n}\n\nmodule.exports = StoreLoader;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/base/LoaderBase.js":"'use strict';\n\n/**\n * Implements the basic Loader class for both server\n * and browser environments.\n */\nclass LoaderBase {\n\n\t/**\n\t * Creates a new instance of the basic loader.\n\t * @param {ServiceLocator} locator The service locator for resolving dependencies.\n\t * @param {Array} transforms The list of module transformations.\n\t */\n\tconstructor(locator, transforms) {\n\n\t\t/**\n\t\t * Current list of module transformations.\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._transforms = transforms;\n\t\tthis._eventBus = locator.resolve('eventBus');\n\t}\n\n\t/**\n\t * Applies all the transformations for the loaded module.\n\t * @param {Object} module The loaded module.\n\t * @param {number?} index The transformation index in the list.\n\t * @returns {Promise<Object>} The transformed module.\n\t * @protected\n\t */\n\t_applyTransforms(module, index) {\n\t\tif (index === undefined) {\n\t\t\t// the list is a stack, we should reverse it\n\t\t\tindex = this._transforms.length - 1;\n\t\t}\n\n\t\tif (index < 0) {\n\t\t\treturn Promise.resolve(module);\n\t\t}\n\n\t\tconst transformation = this._transforms[index];\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() => transformation.transform(module))\n\t\t\t.catch(reason => {\n\t\t\t\tthis._eventBus.emit('error', reason);\n\t\t\t\treturn module;\n\t\t\t})\n\t\t\t.then(transformedModule => this._applyTransforms(transformedModule, index - 1));\n\t}\n}\n\nmodule.exports = LoaderBase;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/loaders/ComponentLoader.js":"'use strict';\n\nconst fs = require('../promises/fs');\nconst requireHelper = require('../helpers/requireHelper');\nconst moduleHelper = require('../helpers/moduleHelper');\nconst loadHelper = require('../helpers/loadHelper');\nconst templateHelper = require('../helpers/templateHelper');\nconst path = require('path');\nconst LoaderBase = require('../base/LoaderBase');\n\n/**\n * Implements the component Loader class for server environment.\n */\nclass ComponentLoader extends LoaderBase {\n\n\t/**\n\t * Creates new instance of the component loader.\n\t * @param {ServiceLocator} locator The service locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\t\tvar componentTransforms;\n\t\ttry {\n\t\t\tcomponentTransforms = locator.resolveAll('componentTransform');\n\t\t} catch (e) {\n\t\t\tcomponentTransforms = [];\n\t\t}\n\t\tsuper(locator, componentTransforms);\n\n\t\t/**\n\t\t * Current event bus.\n\t\t * @type {EventEmitter}\n\t\t * @private\n\t\t */\n\t\tthis._eventBus = locator.resolve('eventBus');\n\n\t\t/**\n\t\t * Current template provider list.\n\t\t * @type {Array<TemplateProvider>}\n\t\t * @private\n\t\t */\n\t\tthis._templateProviders = templateHelper.resolveTemplateProviders(locator);\n\n\t\t/**\n\t\t * Current component finder.\n\t\t * @type {ComponentFinder}\n\t\t * @private\n\t\t */\n\t\tthis._componentFinder = locator.resolve('componentFinder');\n\n\t\t/**\n\t\t * Current release flag.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._isRelease = Boolean(locator.resolve('config').isRelease);\n\n\t\t/**\n\t\t * Current map of the loaded components by their names.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._loadedComponents = null;\n\t}\n\n\t/**\n\t * Loads all components into the memory.\n\t * @returns {Promise<Object>} The promise for map of loaded components.\n\t */\n\tload() {\n\t\tif (this._loadedComponents) {\n\t\t\treturn Promise.resolve(this._loadedComponents);\n\t\t}\n\n\t\tvar isDocumentFound = false;\n\t\tconst result = Object.create(null);\n\n\t\treturn this._componentFinder.find()\n\t\t\t.then(components => {\n\t\t\t\tconst componentPromises = Object.keys(components)\n\t\t\t\t\t.map(componentName => {\n\t\t\t\t\t\tconst componentDetails = components[componentName];\n\t\t\t\t\t\tif (moduleHelper.isDocumentComponent(componentDetails.name)) {\n\t\t\t\t\t\t\tisDocumentFound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this._getComponent(componentDetails);\n\t\t\t\t\t});\n\n\t\t\t\treturn Promise.all(componentPromises);\n\t\t\t})\n\t\t\t.then(componentList => {\n\t\t\t\tcomponentList.forEach(component => {\n\t\t\t\t\tif (!component || typeof (component) !== 'object') {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[component.name] = component;\n\t\t\t\t});\n\n\t\t\t\tthis._loadedComponents = result;\n\n\t\t\t\tif (!this._isRelease) {\n\t\t\t\t\tthis._eventBus.emit('info', 'Watching components for changes...');\n\t\t\t\t\tthis._componentFinder.watch();\n\t\t\t\t\tthis._handleChanges();\n\t\t\t\t}\n\t\t\t\tif (!isDocumentFound) {\n\t\t\t\t\tthis._eventBus.emit('warn',\n\t\t\t\t\t\t`Component \"${moduleHelper.DOCUMENT_COMPONENT_NAME}\" not found, blank page will be rendered`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tthis._eventBus.emit('allComponentsLoaded', result);\n\t\t\t\treturn this._loadedComponents;\n\t\t\t});\n\t}\n\n\t/**\n\t * Gets current map of components by their names.\n\t * @returns {Object} The map of components by their names.\n\t */\n\tgetComponentsByNames() {\n\t\treturn this._loadedComponents || Object.create(null);\n\t}\n\n\t/**\n\t * Gets a component object by the found component details.\n\t * @param {Object} componentDetails The found details.\n\t * @returns {Object} The component object.\n\t * @private\n\t */\n\t_getComponent(componentDetails) {\n\t\tconst logicPath = this._getLogicPath(componentDetails);\n\n\t\tvar constructor;\n\t\ttry {\n\t\t\tconstructor = require(logicPath);\n\t\t} catch (e) {\n\t\t\tthis._eventBus.emit('error', e);\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\n\t\tif (typeof (constructor) !== 'function') {\n\t\t\tthis._eventBus.emit('warn',\n\t\t\t\t`File at ${logicPath} of component \"${componentDetails.name}\" not found or does not export a constructor function. Skipping...`\n\t\t\t);\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\n\t\tvar component = Object.create(componentDetails);\n\t\tcomponent.constructor = constructor;\n\n\t\treturn loadHelper.loadTemplateSources(component)\n\t\t\t.then(() => loadHelper.assignTemplateProviders(component, this._templateProviders))\n\t\t\t.then(() => loadHelper.compileTemplates(component))\n\t\t\t.then(() => this._applyTransforms(component)\n\t\t\t\t\t.then(transformed => {\n\t\t\t\t\t\tif (!transformed) {\n\t\t\t\t\t\t\tthrow new Error(`Transformation for the \"${component.name}\" component returned a bad result`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcomponent = transformed;\n\t\t\t\t\t\treturn templateHelper.registerTemplates(component);\n\t\t\t\t\t})\n\t\t\t)\n\t\t\t.then(() => {\n\t\t\t\tthis._eventBus.emit('componentLoaded', component);\n\t\t\t\treturn component;\n\t\t\t})\n\t\t\t.catch(reason => {\n\t\t\t\tthis._eventBus.emit('error', reason);\n\t\t\t\treturn null;\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles changes while watching.\n\t * @private\n\t */\n\t_handleChanges() {\n\t\tconst loadComponent = componentDetails => this._getComponent(componentDetails)\n\t\t\t.then(component => (this._loadedComponents[componentDetails.name] = component));\n\n\t\tthis._componentFinder\n\t\t\t.on('add', componentDetails => {\n\t\t\t\tthis._eventBus.emit('info', `Component \"${componentDetails.path}\" has been added, initializing...`);\n\t\t\t\trequireHelper.clearCacheKey(this._getLogicPath(componentDetails));\n\t\t\t\tloadComponent(componentDetails);\n\t\t\t})\n\t\t\t.on('changeLogic', componentDetails => {\n\t\t\t\tthis._eventBus.emit('info', `Scripts of the \"${componentDetails.path}\" component have been changed, reinitializing...`);\n\t\t\t\trequireHelper.clearCacheKey(this._getLogicPath(componentDetails));\n\t\t\t\tloadComponent(componentDetails);\n\t\t\t})\n\t\t\t.on('changeTemplates', componentDetails => {\n\t\t\t\tthis._eventBus.emit('info', `Template of the \"${componentDetails.path}\" component have been changed, reinitializing...`);\n\t\t\t\tloadComponent(componentDetails);\n\t\t\t})\n\t\t\t.on('unlink', componentDetails => {\n\t\t\t\tthis._eventBus.emit('info', `Component \"${componentDetails.path}\" has been unlinked, removing...`);\n\t\t\t\trequireHelper.clearCacheKey(this._getLogicPath(componentDetails));\n\t\t\t\tdelete this._loadedComponents[componentDetails.name];\n\t\t\t});\n\t}\n\n\t/**\n\t * Gets an absolute path to the component's logic file.\n\t * @param {Object} componentDetails The component details object.\n\t * @returns {string} The absolute path to the logic file.\n\t * @private\n\t */\n\t_getLogicPath(componentDetails) {\n\t\treturn path.resolve(\n\t\t\tpath.dirname(componentDetails.path), componentDetails.properties.logic\n\t\t);\n\t}\n}\n\nmodule.exports = ComponentLoader;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/DocumentRenderer.js":"'use strict';\n\nconst DocumentRendererBase = require('./base/DocumentRendererBase');\nconst ComponentReadable = require('./streams/ComponentReadable');\n\nclass DocumentRenderer extends DocumentRendererBase {\n\n\t/**\n\t * Creates a new instance of the document renderer.\n\t * @param {ServiceLocator} locator The service locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\t\tsuper(locator);\n\t}\n\n\t/**\n\t * Renders a response on the request with the specified state and routing context.\n\t * @param {Object} state State of the application.\n\t * @param {Object} routingContext Routing Context.\n\t */\n\trender(state, routingContext) {\n\t\tthis._getPromiseForReadyState()\n\t\t\t.then(() => {\n\t\t\t\tconst renderingContext = {\n\t\t\t\t\tisDocumentRendered: false,\n\t\t\t\t\tisHeadRendered: false,\n\t\t\t\t\tconfig: this._serviceLocator.resolve('config'),\n\t\t\t\t\troutingContext,\n\t\t\t\t\tstoreDispatcher: this._serviceLocator.resolve('storeDispatcher'),\n\t\t\t\t\teventBus: this._eventBus,\n\t\t\t\t\tcomponents: this._componentLoader.getComponentsByNames()\n\t\t\t\t};\n\t\t\t\trenderingContext.storeDispatcher.setState(state, routingContext);\n\n\t\t\t\tconst renderStream = new ComponentReadable(renderingContext);\n\n\t\t\t\trenderStream.renderDocument();\n\t\t\t\trenderStream\n\t\t\t\t\t.pipe(routingContext.middleware.response)\n\t\t\t\t\t.on('finish', () => this._eventBus.emit('documentRendered', routingContext));\n\t\t\t})\n\t\t\t.catch(reason => this._eventBus.emit('error', reason));\n\t}\n}\n\nmodule.exports = DocumentRenderer;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/base/DocumentRendererBase.js":"'use strict';\n\n/**\n * Implements the basic Cookie Wrapper class for both server\n * and browser environments.\n */\nclass DocumentRendererBase {\n\n\t/**\n\t * Creates a new instance of the basic document renderer.\n\t * @param {ServiceLocator} locator The locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\n\t\t/**\n\t\t * Current service locator.\n\t\t * @type {ServiceLocator}\n\t\t * @protected\n\t\t */\n\t\tthis._serviceLocator = locator;\n\n\t\t/**\n\t\t * Current context factory.\n\t\t * @type {ContextFactory}\n\t\t * @protected\n\t\t */\n\t\tthis._contextFactory = locator.resolve('contextFactory');\n\n\t\t/**\n\t\t * Current component loader.\n\t\t * @type {ComponentLoader}\n\t\t * @protected\n\t\t */\n\t\tthis._componentLoader = locator.resolve('componentLoader');\n\n\t\t/**\n\t\t * Current event bus.\n\t\t * @param  {EventEmitter}\n\t\t */\n\t\tthis._eventBus = locator.resolve('eventBus');\n\n\t\tconst storeLoader = locator.resolve('storeLoader');\n\n\t\t/**\n\t\t * Current module loading promise.\n\t\t * @type {Promise}\n\t\t * @protected\n\t\t */\n\t\tthis._loading = Promise.all([\n\t\t\tthis._componentLoader.load(),\n\t\t\tstoreLoader.load()\n\t\t])\n\t\t\t.then(() => {\n\t\t\t\tthis._loading = null;\n\t\t\t\tthis._eventBus.emit('ready');\n\t\t\t})\n\t\t\t.catch(reason => this._eventBus.emit('error', reason));\n\t}\n\n\t/**\n\t * Gets a promise for the state when Catberry will be able to handle requests.\n\t * @returns {Promise} Promise for nothing.\n\t * @protected\n\t */\n\t_getPromiseForReadyState() {\n\t\treturn this._loading ?\n\t\t\tthis._loading :\n\t\t\tPromise.resolve();\n\t}\n}\n\nmodule.exports = DocumentRendererBase;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/streams/ComponentReadable.js":"'use strict';\n\nconst stream = require('stream');\nconst entities = require('entities');\nconst moduleHelper = require('../helpers/moduleHelper');\nconst hrTimeHelper = require('../helpers/hrTimeHelper');\nconst errorHelper = require('../helpers/errorHelper');\nconst HTMLTagTokenizer = require('./../tokenizers/HTMLTagTokenizer');\nconst tagTokenizer = new HTMLTagTokenizer();\nconst HTMLTokenizer = require('./../tokenizers/HTMLTokenizer');\nconst tokenizer = new HTMLTokenizer();\n\nconst BODY_TAG = 'body';\nconst CONTENT_TYPE = 'text/html; charset=utf-8';\nconst POWERED_BY = 'Catberry';\n\nconst HTML_ENTITY_REFERENCE_REGEXP = /\\&#?\\w+;/ig;\n\nclass ComponentReadable extends stream.Readable {\n\n\t/**\n\t * Creates a new instance of the parser duplex stream.\n\t * @param {Object} context Rendering parameters.\n\t * @param {Object?} options Stream options.\n\t */\n\tconstructor(context, options) {\n\t\tsuper(options);\n\n\t\t/**\n\t\t * Current rendering context.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._context = context;\n\n\t\t/**\n\t\t * Current queue of found tags.\n\t\t * @type {Array}\n\t\t * @private\n\t\t */\n\t\tthis._tokenQueue = [];\n\n\t\t/**\n\t\t * Current promise if tag is processing asynchronously.\n\t\t * @type {Promise}\n\t\t * @private\n\t\t */\n\t\tthis._processingFoundTagPromise = null;\n\n\t\t/**\n\t\t * Current HTML delayed for response.\n\t\t * @type {string}\n\t\t * @private\n\t\t */\n\t\tthis._delayedHTML = '';\n\n\t\t/**\n\t\t * Is delayed HTML flushed to the response.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._isFlushed = false;\n\n\t\t/**\n\t\t * Is rendering process canceled.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._isCanceled = false;\n\t}\n\n\t/**\n\t * Handles the HTML from found tag handler.\n\t * @param {string} html HTML.\n\t */\n\trenderHTML(html) {\n\t\ttokenizer.setHTMLString(html);\n\t\tconst queue = [];\n\t\tvar tokenDescriptor;\n\t\twhile ((tokenDescriptor = tokenizer.next()).value !== null) {\n\t\t\tqueue.push(tokenDescriptor);\n\t\t}\n\t\tthis._tokenQueue = queue.concat(this._tokenQueue);\n\t\tthis._processingFoundTagPromise = null;\n\t\tthis.read(0);\n\t}\n\n\t/**\n\t * Starts rendering the document template.\n\t */\n\trenderDocument() {\n\t\t// if we did not render anything then start from root template\n\t\tif (this._isCanceled || this._context.isDocumentRendered) {\n\t\t\treturn;\n\t\t}\n\t\tthis._processingFoundTagPromise = this._foundComponentHandler({\n\t\t\tname: moduleHelper.DOCUMENT_COMPONENT_NAME,\n\t\t\tattributes: Object.create(null)\n\t\t});\n\n\t\tif (this._processingFoundTagPromise) {\n\t\t\tthis._processingFoundTagPromise = this._processingFoundTagPromise\n\t\t\t\t.then(html => this.renderHTML(html));\n\t\t}\n\t}\n\n\t/**\n\t * Handles found component tags.\n\t * @param {Object} tagDetails Object with tag details.\n\t * @returns {Promise<string>|null} Replacement stream of HTML.\n\t * @private\n\t */\n\t/* eslint complexity: 0 */\n\t_foundComponentHandler(tagDetails) {\n\t\tif (this._isCanceled) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (tagDetails.name === BODY_TAG) {\n\t\t\tconst inlineScript = this._context.routingContext.getInlineScript();\n\t\t\treturn inlineScript ? Promise.resolve(inlineScript) : null;\n\t\t}\n\n\t\tconst componentName = moduleHelper.getOriginalComponentName(tagDetails.name);\n\t\tconst isDocument = moduleHelper.isDocumentComponent(tagDetails.name);\n\t\tconst isHead = moduleHelper.isHeadComponent(tagDetails.name);\n\n\t\tif (isDocument) {\n\t\t\tif (this._context.isDocumentRendered) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._context.isDocumentRendered = true;\n\t\t} else if (isHead) {\n\t\t\tif (this._context.isHeadRendered ||\n\t\t\t\t!this._context.components[componentName]) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._context.isHeadRendered = true;\n\t\t}\n\n\t\tconst component = this._context.components[componentName];\n\t\tif (!component) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst componentContext = Object.create(this._context);\n\n\t\tcomponentContext.currentComponent = component;\n\t\tcomponentContext.currentAttributes = tagDetails.attributes;\n\n\t\treturn this._renderComponent(componentContext)\n\t\t\t.then(html => {\n\t\t\t\tif (!isDocument) {\n\t\t\t\t\tthis._initializeResponse();\n\t\t\t\t}\n\t\t\t\treturn html;\n\t\t\t});\n\t}\n\n\t/**\n\t * Reads the next chunk of data from this stream.\n\t * @private\n\t */\n\t/* jshint maxcomplexity:false */\n\t_read() {\n\t\tif (this._processingFoundTagPromise) {\n\t\t\tthis.push('');\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._tokenQueue.length === 0 || this._isCanceled) {\n\t\t\tthis.push(null);\n\t\t\treturn;\n\t\t}\n\n\t\tvar toPush = '';\n\t\twhile (this._tokenQueue.length > 0) {\n\t\t\tconst tokenItem = this._tokenQueue.shift();\n\n\t\t\tif (tokenItem.state !== HTMLTokenizer.STATES.COMPONENT) {\n\t\t\t\ttoPush += tokenItem.value;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst tagDetails = this._parseTag(tokenItem.value);\n\t\t\tif (!tagDetails) {\n\t\t\t\ttoPush += tokenItem.value;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst processingPromise = this._foundComponentHandler(tagDetails);\n\n\t\t\tif (!processingPromise) {\n\t\t\t\ttoPush += tokenItem.value;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// we should open self-closed component tags\n\t\t\t// to set content into them\n\t\t\tif (tagDetails.isSelfClosed) {\n\t\t\t\ttokenItem.value = tokenItem.value.replace(/\\/\\w*>$/, '>');\n\t\t\t\tthis._tokenQueue.unshift({\n\t\t\t\t\ttoken: HTMLTokenizer.STATES.CONTENT,\n\t\t\t\t\tvalue: `</${tagDetails.name}>`\n\t\t\t\t});\n\t\t\t}\n\n\t\t\ttoPush += tokenItem.value;\n\n\t\t\tthis._processingFoundTagPromise = processingPromise.then(html => this.renderHTML(html));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (this._isFlushed) {\n\t\t\tthis.push(toPush);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._delayedHTML += toPush;\n\n\t\tif (!this._processingFoundTagPromise && this._tokenQueue.length === 0) {\n\t\t\tthis._initializeResponse();\n\t\t}\n\t}\n\n\t/**\n\t * Parses the entire HTML tag.\n\t * @param {string} tagString Found tag token.\n\t * @returns {Object} Tag details.\n\t */\n\t_parseTag(tagString) {\n\t\ttagTokenizer.setTagString(tagString);\n\t\tconst tag = {\n\t\t\tname: '',\n\t\t\tattributes: Object.create(null),\n\t\t\tisSelfClosed: false\n\t\t};\n\n\t\tvar lastAttributeName = '';\n\t\tvar current, currentString;\n\n\t\t/* eslint no-constant-condition: 0 */\n\t\twhile (true) {\n\t\t\tcurrent = tagTokenizer.next();\n\t\t\tswitch (current.state) {\n\t\t\t\tcase HTMLTagTokenizer.STATES.TAG_NAME:\n\t\t\t\t\ttag.name = tagString\n\t\t\t\t\t\t.substring(current.start, current.end)\n\t\t\t\t\t\t.toLowerCase();\n\t\t\t\t\tbreak;\n\t\t\t\tcase HTMLTagTokenizer.STATES.ATTRIBUTE_NAME:\n\t\t\t\t\tcurrentString = tagString\n\t\t\t\t\t\t.substring(current.start, current.end)\n\t\t\t\t\t\t.toLowerCase();\n\t\t\t\t\ttag.attributes[currentString] = true;\n\t\t\t\t\tlastAttributeName = currentString;\n\t\t\t\t\tbreak;\n\t\t\t\tcase HTMLTagTokenizer.STATES.ATTRIBUTE_VALUE_DOUBLE_QUOTED:\n\t\t\t\tcase HTMLTagTokenizer.STATES.ATTRIBUTE_VALUE_SINGLE_QUOTED:\n\t\t\t\tcase HTMLTagTokenizer.STATES.ATTRIBUTE_VALUE_UNQUOTED:\n\t\t\t\t\tcurrentString = tagString\n\t\t\t\t\t\t.substring(current.start, current.end)\n\t\t\t\t\t\t.replace(HTML_ENTITY_REFERENCE_REGEXP, entities.decode);\n\t\t\t\t\ttag.attributes[lastAttributeName] = currentString;\n\t\t\t\t\tbreak;\n\t\t\t\tcase HTMLTagTokenizer.STATES.SELF_CLOSING_START_TAG_STATE:\n\t\t\t\t\ttag.isSelfClosed = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase HTMLTagTokenizer.STATES.TAG_CLOSE:\n\t\t\t\t\treturn tag;\n\t\t\t\tcase HTMLTagTokenizer.STATES.ILLEGAL:\n\t\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Renders the component.\n\t * @param {Object} context Component's rendering context.\n\t * @returns {Promise<string>} HTML.\n\t * @private\n\t */\n\t_renderComponent(context) {\n\t\tconst locator = context.routingContext.locator;\n\t\tconst component = context.currentComponent;\n\n\t\tif (typeof (component.constructor) !== 'function') {\n\t\t\treturn Promise.resolve('');\n\t\t}\n\n\t\tcomponent.constructor.prototype.$context = this._getComponentContext(context);\n\n\t\ttry {\n\t\t\tcontext.instance = new component.constructor(locator);\n\t\t} catch (e) {\n\n\t\t\treturn moduleHelper.getSafePromise(() => this._handleComponentError(context, e));\n\t\t}\n\n\t\tcontext.instance.$context = component.constructor.prototype.$context;\n\n\t\tconst startTime = hrTimeHelper.get();\n\t\tconst eventArgs = {\n\t\t\tname: component.name,\n\t\t\tcontext: context.instance.$context\n\t\t};\n\n\t\tconst renderMethod = moduleHelper.getMethodToInvoke(context.instance, 'render');\n\t\tconst isDocument = moduleHelper.isDocumentComponent(component.name);\n\t\tconst isHead = moduleHelper.isHeadComponent(component.name);\n\n\t\tthis._context.eventBus.emit('componentRender', eventArgs);\n\n\t\treturn moduleHelper.getSafePromise(renderMethod)\n\t\t\t// if data context has been returned\n\t\t\t// then render template\n\t\t\t.then(dataContext => {\n\t\t\t\tdataContext = dataContext || Object.create(null);\n\t\t\t\treturn component.template.render(dataContext);\n\t\t\t})\n\t\t\t// if template has been rendered\n\t\t\t// component has been successfully rendered then return html\n\t\t\t.then(html => {\n\t\t\t\teventArgs.hrTime = hrTimeHelper.get(startTime);\n\t\t\t\teventArgs.time = hrTimeHelper.toMilliseconds(eventArgs.hrTime);\n\n\t\t\t\tthis._context.eventBus.emit('componentRendered', eventArgs);\n\n\t\t\t\tconst inlineScript = !isDocument && !isHead ?\n\t\t\t\t\tcontext.instance.$context.getInlineScript() : '';\n\t\t\t\treturn inlineScript + html;\n\t\t\t})\n\t\t\t.catch(reason => this._handleComponentError(context, reason));\n\t}\n\n\t/**\n\t * Handles a rendering error.\n\t * @param {Object} context Rendering context.\n\t * @param {Error} error Rendering error.\n\t * @private\n\t */\n\t_handleComponentError(context, error) {\n\t\t// if application in debug mode then render\n\t\t// error text in component\n\t\tconst isRelease = Boolean(context.config.isRelease);\n\t\tconst component = context.currentComponent;\n\n\t\tif (!isRelease && error instanceof Error &&\n\t\t\t!moduleHelper.isDocumentComponent(component.name) &&\n\t\t\t!moduleHelper.isHeadComponent(component.name)) {\n\t\t\tthis._context.eventBus.emit('error', error);\n\t\t\ttry {\n\t\t\t\treturn errorHelper.prettyPrint(error, context.routingContext.userAgent);\n\t\t\t} catch (e) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\n\t\tif (component.errorTemplate) {\n\t\t\treturn moduleHelper.getSafePromise(() => component.errorTemplate.render(error))\n\t\t\t\t.catch(reason => {\n\t\t\t\t\tthis._context.eventBus.emit('error', reason);\n\t\t\t\t\treturn '';\n\t\t\t\t});\n\t\t}\n\n\t\tthis._context.eventBus.emit('error', error);\n\t\treturn '';\n\t}\n\n\t/**\n\t * Gets the component's context using basic context.\n\t * @param {Object} context Rendering context.\n\t * @returns {Object} Component context.\n\t * @private\n\t */\n\t_getComponentContext(context) {\n\t\tconst attributes = context.currentAttributes;\n\t\tconst storeName = attributes[moduleHelper.ATTRIBUTE_STORE];\n\t\tconst componentContext = Object.create(context.routingContext);\n\n\t\tcomponentContext.element = null;\n\t\tcomponentContext.name = context.currentComponent.name;\n\t\tcomponentContext.attributes = attributes;\n\n\t\t// search methods\n\t\tcomponentContext.getComponentById = nullStub;\n\t\tcomponentContext.getComponentByElement = nullStub;\n\t\tcomponentContext.getComponentsByTagName = arrayStub;\n\t\tcomponentContext.getComponentsByClassName = arrayStub;\n\t\tcomponentContext.queryComponentSelector = nullStub;\n\t\tcomponentContext.queryComponentSelectorAll = arrayStub;\n\n\t\t// create/remove\n\t\tcomponentContext.createComponent = promiseStub;\n\t\tcomponentContext.collectGarbage = promiseStub;\n\n\t\t// store methods\n\t\tcomponentContext.getStoreData =\n\t\t\t() => context.storeDispatcher.getStoreData(storeName);\n\t\tcomponentContext.sendAction =\n\t\t\t(name, args) => context.storeDispatcher.sendAction(storeName, name, args);\n\n\t\treturn Object.freeze(componentContext);\n\t}\n\n\t/**\n\t * Initializes a HTTP response with the required code and headers.\n\t * @private\n\t */\n\t_initializeResponse() {\n\t\tif (this._isFlushed) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isFlushed = true;\n\n\t\tconst routingContext = this._context.routingContext;\n\t\tconst response = routingContext.middleware.response;\n\n\t\tif (routingContext.actions.redirectedTo) {\n\t\t\tresponse.writeHead(routingContext.actions.redirectionStatusCode, {\n\t\t\t\tLocation: routingContext.actions.redirectedTo\n\t\t\t});\n\t\t\troutingContext.actions.redirectedTo = '';\n\t\t\troutingContext.actions.redirectionStatusCode = null;\n\t\t\tthis._isCanceled = true;\n\t\t\tthis.push(null);\n\t\t\treturn;\n\t\t}\n\n\t\tif (routingContext.actions.isNotFoundCalled) {\n\t\t\troutingContext.actions.isNotFoundCalled = false;\n\t\t\tthis._isCanceled = true;\n\t\t\troutingContext.middleware.next();\n\t\t\treturn;\n\t\t}\n\n\t\tconst headers = {\n\t\t\t'Content-Type': CONTENT_TYPE,\n\t\t\t'X-Powered-By': POWERED_BY\n\t\t};\n\t\tif (routingContext.cookie.setCookie.length > 0) {\n\t\t\theaders['Set-Cookie'] = routingContext.cookie.setCookie;\n\t\t}\n\t\tresponse.writeHead(200, headers);\n\t\troutingContext.cookie.setCookie = [];\n\n\t\tif (this._delayedHTML) {\n\t\t\tthis.push(this._delayedHTML);\n\t\t\tthis._delayedHTML = '';\n\t\t}\n\t}\n}\n\n/**\n * Does nothing as a stub method.\n * @returns {null} Always null.\n */\nfunction nullStub() {\n\treturn null;\n}\n\n/**\n * Does nothing as a stub method.\n * @returns {Promise} Always a promise for null.\n */\nfunction promiseStub() {\n\treturn Promise.resolve(null);\n}\n\n/**\n * Does nothing as a stub method.\n * @returns {Array} Always an empty array.\n */\nfunction arrayStub() {\n\treturn [];\n}\n\nmodule.exports = ComponentReadable;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/helpers/errorHelper.js":"'use strict';\n\nconst ERROR_MESSAGE_REGEXP = /^(?:[\\w$]+): (?:.+)\\r?\\n/i;\n\nmodule.exports = {\n\n\t/**\n\t * Prints an error with pretty formatting.\n\t * @param {Error} error The error to print.\n\t * @param {string} userAgent The user agent information.\n\t * @returns {string} HTML text with all information about the error.\n\t */\n\tprettyPrint: (error, userAgent) => {\n\t\tif (!error || typeof (error) !== 'object') {\n\t\t\treturn '';\n\t\t}\n\t\treturn `\n<div style=\"background-color: white; font-size: 12pt;\">\n\t${(new Date()).toUTCString()};<br/>\n\t${userAgent || 'Unknown browser'};<br/>\n\tCatberry@9.0.0 (\n\t<a href=\"https://github.com/catberry/catberry/issues\" target=\"_blank\">\n\t\treport an issue\n\t</a>)\n\t<br/><br/>\n\t<span style=\"color: red; font-size: 16pt; font-weight: bold;\">\n\t\t${escape(error.name)}: ${escape(error.message)}\n\t</span>\n\t<br/><br/>\n\t${escape(error.stack).replace(ERROR_MESSAGE_REGEXP, '')}\n</div>\n`;\n\t}\n};\n\n/**\n * Escapes the error text.\n * @param {string} value The error text to escape.\n * @returns {string} The escaped and formatted string.\n */\nfunction escape(value) {\n\tvalue = String(value || '');\n\treturn value\n\t\t.replace(/&/g, '&amp;')\n\t\t.replace(/</g, '&lt;')\n\t\t.replace(/>/g, '&gt;')\n\t\t.replace(/\\\"/g, '&quot;')\n\t\t.replace(/\\'/g, '&#39;')\n\t\t.replace(/\\r?\\n/g, '<br/>');\n}\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/tokenizers/HTMLTagTokenizer.js":"'use strict';\n\nconst STATES = {\n\tILLEGAL: -1,\n\tNO: 0,\n\tTAG_OPEN: 1,\n\tTAG_NAME: 2,\n\tBEFORE_ATTRIBUTE_NAME: 3,\n\tATTRIBUTE_NAME: 4,\n\tAFTER_ATTRIBUTE_NAME: 5,\n\tBEFORE_ATTRIBUTE_VALUE: 6,\n\tATTRIBUTE_VALUE_DOUBLE_QUOTED: 7,\n\tATTRIBUTE_VALUE_SINGLE_QUOTED: 8,\n\tATTRIBUTE_VALUE_UNQUOTED: 9,\n\tAFTER_ATTRIBUTE_VALUE_QUOTED: 10,\n\tSELF_CLOSING_START_TAG_STATE: 11,\n\tTAG_CLOSE: 12\n};\nObject.freeze(STATES);\n\nconst WHITESPACE_TEST = /^[\\u0009\\u000A\\u000C\\u000D\\u0020]$/;\nconst ASCII_LETTERS_TEST = /[a-z]/i;\n\nclass HTMLTagTokenizer {\n\n\t/**\n\t * Creates a new instance of the HTML tag tokenizer.\n\t * It was developed using this specification:\n\t * http://www.w3.org/TR/2011/WD-html5-20110113/tokenization.html\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * Current source code of constructor.\n\t\t * @type {string}\n\t\t * @private\n\t\t */\n\t\tthis._source = '';\n\n\t\t/**\n\t\t * Current index in source code.\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._currentIndex = 0;\n\n\t\t/**\n\t\t * Current index in source code.\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._currentEnd = 0;\n\n\t\t/**\n\t\t * Current state.\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._currentState = STATES.NO;\n\t}\n\n\t/**\n\t * Gets the state constants map.\n\t */\n\tstatic get STATES() {\n\t\treturn STATES;\n\t}\n\n\t/**\n\t * Sets the tag string to tokenize.\n\t * @param {string} tagHTML Tag HTML string.\n\t */\n\tsetTagString(tagHTML) {\n\t\tthis._source = tagHTML;\n\t\tthis._currentIndex = 0;\n\t\tthis._currentEnd = 0;\n\t\tthis._currentState = STATES.NO;\n\t}\n\n\t/**\n\t * Gets a next token in source.\n\t * @returns {{state: (number), start: number, end: number}}\n\t */\n\t/* eslint complexity: 0 */\n\tnext() {\n\t\tconst start = this._currentIndex;\n\t\tconst state = this._currentState;\n\n\t\tswitch (this._currentState) {\n\t\t\tcase STATES.TAG_OPEN:\n\t\t\t\tthis.tagOpenState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.TAG_NAME:\n\t\t\t\tthis.tagNameState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.SELF_CLOSING_START_TAG_STATE:\n\t\t\t\tthis.selfClosingStartTagState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.BEFORE_ATTRIBUTE_NAME:\n\t\t\t\tthis.beforeAttributeNameState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.ATTRIBUTE_NAME:\n\t\t\t\tthis.attributeNameState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.AFTER_ATTRIBUTE_NAME:\n\t\t\t\tthis.afterAttributeNameState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.BEFORE_ATTRIBUTE_VALUE:\n\t\t\t\tthis.beforeAttributeValueState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.ATTRIBUTE_VALUE_DOUBLE_QUOTED:\n\t\t\t\tthis.attributeValueDoubleQuotedState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.ATTRIBUTE_VALUE_SINGLE_QUOTED:\n\t\t\t\tthis.attributeValueSingleQuotedState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.ATTRIBUTE_VALUE_UNQUOTED:\n\t\t\t\tthis.attributeValueUnquotedState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.AFTER_ATTRIBUTE_VALUE_QUOTED:\n\t\t\t\tthis.afterAttributeValueQuotedState();\n\t\t\t\tbreak;\n\t\t\tcase STATES.ILLEGAL:\n\t\t\tcase STATES.TAG_CLOSE:\n\t\t\t\treturn {\n\t\t\t\t\tstate,\n\t\t\t\t\tstart,\n\t\t\t\t\tend: start + 1\n\t\t\t\t};\n\t\t\tdefault:\n\t\t\t\tthis._currentState = this._source[start] === '<' ?\n\t\t\t\t\tSTATES.TAG_OPEN :\n\t\t\t\t\tSTATES.ILLEGAL;\n\t\t\t\treturn this.next();\n\t\t}\n\n\t\treturn {\n\t\t\tstate,\n\t\t\tstart,\n\t\t\tend: this._currentEnd\n\t\t};\n\t}\n\n\t/**\n\t * Skips all whitespace characters.\n\t */\n\tskipWhitespace() {\n\t\twhile (\n\t\t\tthis._currentIndex < this._source.length &&\n\t\t\tWHITESPACE_TEST.test(this._source[this._currentIndex])\n\t\t) {\n\t\t\tthis._currentIndex++;\n\t\t}\n\t}\n\n\t/**\n\t * Describes the \"Tag open state\".\n\t */\n\ttagOpenState() {\n\t\tthis._currentIndex++;\n\t\tthis._currentEnd = this._currentIndex;\n\t\tconst next = this._source[this._currentIndex];\n\n\t\tif (ASCII_LETTERS_TEST.test(next)) {\n\t\t\tthis._currentState = STATES.TAG_NAME;\n\t\t\treturn;\n\t\t}\n\n\t\t// this parser does not support the \"Markup declaration open state\" and\n\t\t// \"End tag open state\"\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n\n\t/**\n\t * Describes the \"Tag name state\".\n\t */\n\ttagNameState() {\n\t\tthis._currentIndex++;\n\t\tthis._currentEnd = this._currentIndex;\n\t\twhile (this._currentIndex < this._source.length) {\n\t\t\tconst next = this._source[this._currentIndex];\n\t\t\tif (WHITESPACE_TEST.test(next)) {\n\t\t\t\tthis._currentState = STATES.BEFORE_ATTRIBUTE_NAME;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (next === '/') {\n\t\t\t\tthis._currentState = STATES.SELF_CLOSING_START_TAG_STATE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (next === '>') {\n\t\t\t\tthis._currentState = STATES.TAG_CLOSE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (next === '\\u0000') {\n\t\t\t\tthis._currentState = STATES.ILLEGAL;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._currentIndex++;\n\t\t\tthis._currentEnd = this._currentIndex;\n\t\t}\n\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n\n\t/**\n\t * Describes the \"Self-closing start tag state\".\n\t */\n\tselfClosingStartTagState() {\n\t\tthis._currentIndex++;\n\t\tthis._currentEnd = this._currentIndex;\n\t\tconst next = this._source[this._currentIndex];\n\t\tif (next === '>') {\n\t\t\tthis._currentState = STATES.TAG_CLOSE;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n\n\t/**\n\t * Describes the \"Before attribute value state\".\n\t */\n\tbeforeAttributeNameState() {\n\t\tthis._currentIndex++;\n\t\tthis.skipWhitespace();\n\t\tthis._currentEnd = this._currentIndex;\n\n\t\tconst next = this._source[this._currentIndex];\n\t\tif (next === '/') {\n\t\t\tthis._currentState = STATES.SELF_CLOSING_START_TAG_STATE;\n\t\t\treturn;\n\t\t}\n\t\tif (next === '>') {\n\t\t\tthis._currentState = STATES.TAG_CLOSE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (next === '\\u0000' ||\n\t\t\tnext === '\"' ||\n\t\t\tnext === '\\'' ||\n\t\t\tnext === '<' ||\n\t\t\tnext === '=' ||\n\t\t\tthis._currentIndex >= this._source.length) {\n\t\t\tthis._currentState = STATES.ILLEGAL;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentState = STATES.ATTRIBUTE_NAME;\n\t}\n\n\t/**\n\t * Describes the \"Attribute name state\".\n\t */\n\tattributeNameState() {\n\t\tthis._currentIndex++;\n\t\tthis._currentEnd = this._currentIndex;\n\n\t\twhile (this._currentIndex < this._source.length) {\n\t\t\tconst next = this._source[this._currentIndex];\n\t\t\tif (WHITESPACE_TEST.test(next)) {\n\t\t\t\tthis._currentState = STATES.AFTER_ATTRIBUTE_NAME;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (next === '/') {\n\t\t\t\tthis._currentState = STATES.SELF_CLOSING_START_TAG_STATE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (next === '=') {\n\t\t\t\tthis._currentState = STATES.BEFORE_ATTRIBUTE_VALUE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (next === '>') {\n\t\t\t\tthis._currentState = STATES.TAG_CLOSE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (next === '\\u0000' ||\n\t\t\t\tnext === '\"' ||\n\t\t\t\tnext === '\\'' ||\n\t\t\t\tnext === '<') {\n\t\t\t\tthis._currentState = STATES.ILLEGAL;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._currentIndex++;\n\t\t\tthis._currentEnd = this._currentIndex;\n\t\t}\n\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n\n\t/**\n\t * Describes the \"After attribute value state\".\n\t */\n\tafterAttributeNameState() {\n\t\tthis._currentIndex++;\n\t\tthis.skipWhitespace();\n\t\tthis._currentEnd = this._currentIndex;\n\n\t\tconst next = this._source[this._currentIndex];\n\t\tif (next === '/') {\n\t\t\tthis._currentState = STATES.SELF_CLOSING_START_TAG_STATE;\n\t\t\treturn;\n\t\t}\n\t\tif (next === '=') {\n\t\t\tthis._currentState = STATES.BEFORE_ATTRIBUTE_VALUE;\n\t\t\treturn;\n\t\t}\n\t\tif (next === '>') {\n\t\t\tthis._currentState = STATES.TAG_CLOSE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (next === '\\u0000' ||\n\t\t\tnext === '\"' ||\n\t\t\tnext === '\\'' ||\n\t\t\tnext === '<' ||\n\t\t\tthis._currentIndex >= this._source.length) {\n\t\t\tthis._currentState = STATES.ILLEGAL;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentState = STATES.ATTRIBUTE_NAME;\n\t}\n\n\t/**\n\t * Describes the \"Before attribute value state\".\n\t */\n\tbeforeAttributeValueState() {\n\t\tthis._currentIndex++;\n\t\tthis.skipWhitespace();\n\t\tthis._currentEnd = this._currentIndex;\n\n\t\tconst next = this._source[this._currentIndex];\n\n\t\tif (next === '\"') {\n\t\t\tthis._currentIndex++;\n\t\t\tthis._currentEnd = this._currentIndex;\n\t\t\tthis._currentState = STATES.ATTRIBUTE_VALUE_DOUBLE_QUOTED;\n\t\t\treturn;\n\t\t}\n\n\t\tif (next === '\\'') {\n\t\t\tthis._currentIndex++;\n\t\t\tthis._currentEnd = this._currentIndex;\n\t\t\tthis._currentState = STATES.ATTRIBUTE_VALUE_SINGLE_QUOTED;\n\t\t\treturn;\n\t\t}\n\n\t\tif (next === '\\u0000' ||\n\t\t\tnext === '>' ||\n\t\t\tnext === '<' ||\n\t\t\tnext === '=' ||\n\t\t\tnext === '`' ||\n\t\t\tthis._currentIndex >= this._source.length) {\n\t\t\tthis._currentState = STATES.ILLEGAL;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentState = STATES.ATTRIBUTE_VALUE_UNQUOTED;\n\t}\n\n\t/**\n\t * Describes the \"Attribute value (double-quoted) state\".\n\t */\n\tattributeValueDoubleQuotedState() {\n\t\tthis._currentEnd = this._currentIndex;\n\n\t\twhile (this._currentIndex < this._source.length) {\n\t\t\t// character reference in attribute value state is not supported\n\t\t\tconst next = this._source[this._currentIndex];\n\t\t\tif (next === '\"') {\n\t\t\t\tthis._currentState = STATES.AFTER_ATTRIBUTE_VALUE_QUOTED;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (next === '\\u0000') {\n\t\t\t\tthis._currentState = STATES.ILLEGAL;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._currentIndex++;\n\t\t\tthis._currentEnd = this._currentIndex;\n\t\t}\n\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n\n\t/**\n\t * Describes the \"Attribute value (single-quoted) state\".\n\t */\n\tattributeValueSingleQuotedState() {\n\t\tthis._currentEnd = this._currentIndex;\n\n\t\twhile (this._currentIndex < this._source.length) {\n\t\t\t// character reference in attribute value state is not supported\n\t\t\tconst next = this._source[this._currentIndex];\n\t\t\tif (next === '\\'') {\n\t\t\t\tthis._currentState = STATES.AFTER_ATTRIBUTE_VALUE_QUOTED;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (next === '\\u0000') {\n\t\t\t\tthis._currentState = STATES.ILLEGAL;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._currentIndex++;\n\t\t\tthis._currentEnd = this._currentIndex;\n\t\t}\n\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n\n\t/**\n\t * Describes the \"Attribute value (unquoted) state\".\n\t */\n\tattributeValueUnquotedState() {\n\t\tthis._currentIndex++;\n\t\tthis._currentEnd = this._currentIndex;\n\n\t\twhile (this._currentIndex < this._source.length) {\n\t\t\t// character reference in attribute value state is not supported\n\t\t\tconst next = this._source[this._currentIndex];\n\n\t\t\tif (WHITESPACE_TEST.test(next)) {\n\t\t\t\tthis._currentState = STATES.BEFORE_ATTRIBUTE_NAME;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (next === '>') {\n\t\t\t\tthis._currentState = STATES.TAG_CLOSE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (next === '\\u0000' ||\n\t\t\t\tnext === '\\'' ||\n\t\t\t\tnext === '<' ||\n\t\t\t\tnext === '=' ||\n\t\t\t\tnext === '`') {\n\t\t\t\tthis._currentState = STATES.ILLEGAL;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._currentIndex++;\n\t\t\tthis._currentEnd = this._currentIndex;\n\t\t}\n\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n\n\t/**\n\t * Describes the \"After attribute value (quoted) state\".\n\t */\n\tafterAttributeValueQuotedState() {\n\t\tthis._currentIndex++;\n\t\tthis._currentEnd = this._currentIndex;\n\n\t\tconst next = this._source[this._currentIndex];\n\n\t\tif (WHITESPACE_TEST.test(next)) {\n\t\t\tthis._currentState = STATES.BEFORE_ATTRIBUTE_NAME;\n\t\t\treturn;\n\t\t}\n\n\t\tif (next === '/') {\n\t\t\tthis._currentState = STATES.SELF_CLOSING_START_TAG_STATE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (next === '>') {\n\t\t\tthis._currentState = STATES.TAG_CLOSE;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n}\n\nmodule.exports = HTMLTagTokenizer;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/tokenizers/HTMLTokenizer.js":"'use strict';\n\nconst STATES = {\n\tILLEGAL: -1,\n\tINITIAL: 0,\n\tCONTENT: 1,\n\tCOMPONENT: 2,\n\tCOMMENT: 3,\n\tEND: 4\n};\nObject.freeze(STATES);\n\nconst COMPONENT_TAG_NAME_REGEXP = /^<((cat-)|((document|head|body)[\\s/>]))/i;\nconst COMPONENT_NAME_MIN_LENGTH = 10;\n\nclass HTMLTokenizer {\n\n\t/**\n\t * Creates a new instance of the simplified streaming HTML tokenizer.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * Current token buffer.\n\t\t * @type {string}\n\t\t * @private\n\t\t */\n\t\tthis._source = '';\n\n\t\t/**\n\t\t * Current index in buffer.\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._currentIndex = 0;\n\n\t\t/**\n\t\t * Current token identifier.\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._currentState = STATES.INITIAL;\n\t}\n\n\t/**\n\t * Gets the state constants map.\n\t */\n\tstatic get STATES() {\n\t\treturn STATES;\n\t}\n\n\t/**\n\t * Sets a HTML string to the tokenizer.\n\t * @param {string} html HTML string.\n\t */\n\tsetHTMLString(html) {\n\t\tthis._source = html;\n\t\tthis._currentIndex = 0;\n\t\tthis._currentState = STATES.INITIAL;\n\t}\n\n\t/**\n\t * Gets a next token.\n\t * @returns {{state: number, value: string}} Token descriptor.\n\t */\n\tnext() {\n\t\tconst start = this._currentIndex;\n\t\tconst state = this._currentState;\n\n\t\tswitch (this._currentState) {\n\t\t\tcase STATES.CONTENT:\n\t\t\t\tthis.content();\n\t\t\t\tbreak;\n\t\t\tcase STATES.COMPONENT:\n\t\t\t\tthis.component();\n\t\t\t\tbreak;\n\t\t\tcase STATES.COMMENT:\n\t\t\t\tthis.comment();\n\t\t\t\tbreak;\n\t\t\tcase STATES.END:\n\t\t\t\treturn {\n\t\t\t\t\tstate,\n\t\t\t\t\tvalue: null\n\t\t\t\t};\n\t\t\tcase STATES.ILLEGAL:\n\t\t\t\tthis._currentState = STATES.INITIAL;\n\t\t\t\tthis._currentIndex++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.initial();\n\t\t\t\treturn this.next();\n\t\t}\n\n\t\treturn {\n\t\t\tstate,\n\t\t\tvalue: this._source.substring(start, this._currentIndex)\n\t\t};\n\t}\n\n\t/**\n\t * Switches machine to the \"data\" state.\n\t */\n\tinitial() {\n\t\tif (this._currentIndex >= this._source.length) {\n\t\t\tthis._currentState = STATES.END;\n\t\t\treturn;\n\t\t}\n\n\t\t// maybe comment or component\n\t\tif (this._source[this._currentIndex] === '<') {\n\t\t\t// comment\n\t\t\tif (this._source[this._currentIndex + 1] === '!') {\n\t\t\t\tif (this._source[this._currentIndex + 2] === '-' &&\n\t\t\t\t\tthis._source[this._currentIndex + 3] === '-') {\n\t\t\t\t\tthis._currentState = STATES.COMMENT;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._currentState = STATES.CONTENT;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.checkIfComponent()) {\n\t\t\t\tthis._currentState = STATES.COMPONENT;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis._currentState = STATES.CONTENT;\n\t}\n\n\t/**\n\t * Switches machine to the \"tag\" state.\n\t */\n\tcomponent() {\n\t\tthis._currentIndex += 5;\n\t\twhile (this._currentIndex < this._source.length) {\n\t\t\tif (this._source[this._currentIndex] === '>') {\n\t\t\t\tthis._currentIndex++;\n\t\t\t\tthis._currentState = STATES.INITIAL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._currentIndex++;\n\t\t}\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n\n\t/**\n\t * Switches machine to the \"content\" state.\n\t */\n\tcontent() {\n\t\tthis._currentIndex++;\n\t\twhile (this._currentIndex < this._source.length) {\n\t\t\tif (this._source[this._currentIndex] === '<') {\n\t\t\t\tthis._currentState = STATES.INITIAL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._currentIndex++;\n\t\t}\n\t\tthis._currentState = STATES.END;\n\t}\n\n\t/**\n\t * Switches machine to the \"comment\" state.\n\t */\n\tcomment() {\n\t\tthis._currentIndex += 4;\n\n\t\twhile (this._currentIndex < this._source.length) {\n\t\t\tif (this._source[this._currentIndex] === '-') {\n\t\t\t\tif (this._currentIndex + 2 >= this._source.length) {\n\t\t\t\t\tthis._currentState = STATES.ILLEGAL;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (this._source[this._currentIndex + 1] === '-' &&\n\t\t\t\t\tthis._source[this._currentIndex + 2] === '>') {\n\t\t\t\t\tthis._currentIndex += 3;\n\t\t\t\t\tthis._currentState = STATES.INITIAL;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._currentIndex++;\n\t\t}\n\t\tthis._currentState = STATES.ILLEGAL;\n\t}\n\n\t/**\n\t * Checks if following HTML is a component.\n\t * @returns {boolean} Is it a component?\n\t */\n\tcheckIfComponent() {\n\t\tconst testString = this._source.substr(\n\t\t\tthis._currentIndex, COMPONENT_NAME_MIN_LENGTH\n\t\t);\n\t\treturn COMPONENT_TAG_NAME_REGEXP.test(testString);\n\t}\n}\n\nmodule.exports = HTMLTokenizer;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/RequestRouter.js":"'use strict';\n\nconst hrTimeHelper = require('./helpers/hrTimeHelper');\nconst catberryURI = require('catberry-uri');\nconst URI = catberryURI.URI;\nconst Authority = catberryURI.Authority;\n\nclass RequestRouter {\n\n\t/**\n\t * Creates a new instance of the request router.\n\t * @param {ServiceLocator} locator Service locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\n\t\t/**\n\t\t * Current page renderer.\n\t\t * @type {DocumentRenderer}\n\t\t * @private\n\t\t */\n\t\tthis._documentRenderer = locator.resolve('documentRenderer');\n\n\t\t/**\n\t\t * Current state provider.\n\t\t * @type {StateProvider}\n\t\t * @private\n\t\t */\n\t\tthis._stateProvider = locator.resolve('stateProvider');\n\n\t\t/**\n\t\t * Current context factory.\n\t\t * @type {ContextFactory}\n\t\t * @private\n\t\t */\n\t\tthis._contextFactory = locator.resolve('contextFactory');\n\n\t\t/**\n\t\t * Current event bus.\n\t\t * @type {EventEmitter}\n\t\t */\n\t\tthis._eventBus = locator.resolve('eventBus');\n\n\t\t/**\n\t\t * Current service locator.\n\t\t * @type {ServiceLocator}\n\t\t * @private\n\t\t */\n\t\tthis._serviceLocator = locator;\n\t}\n\n\t/**\n\t * Creates a routing context, gets the application state and passes it to the renderer.\n\t * @param {http.IncomingMessage} request HTTP request.\n\t * @param {http.ServerResponse} response HTTP response.\n\t * @param {Function?} next Next function for the middleware.\n\t */\n\troute(request, response, next) {\n\t\tif (!(next instanceof Function)) {\n\t\t\tnext = () => {};\n\t\t}\n\n\t\tif (request.method !== 'GET') {\n\t\t\tnext();\n\t\t\treturn;\n\t\t}\n\n\t\tvar location, referrer;\n\t\ttry {\n\t\t\tlocation = new URI(request.url);\n\t\t} catch (e) {\n\t\t\tlocation = new URI();\n\t\t}\n\t\ttry {\n\t\t\treferrer = new URI(request.headers.referer);\n\t\t} catch (e) {\n\t\t\treferrer = new URI();\n\t\t}\n\n\t\tvar cookieString = '';\n\t\tvar userAgent = '';\n\t\tif (request.headers) {\n\t\t\tlocation.authority = new Authority(request.headers.host);\n\t\t\tuserAgent = String(request.headers['user-agent'] || '');\n\t\t\tcookieString = String(request.headers.cookie || '');\n\t\t}\n\n\t\tconst state = this._stateProvider.getStateByUri(location);\n\t\tif (!state) {\n\t\t\tnext();\n\t\t\treturn;\n\t\t}\n\n\t\tconst routingContext = this._contextFactory.create({\n\t\t\treferrer,\n\t\t\tlocation,\n\t\t\tuserAgent,\n\t\t\tmiddleware: {\n\t\t\t\tresponse,\n\t\t\t\tnext\n\t\t\t}\n\t\t});\n\t\troutingContext.cookie.initWithString(cookieString);\n\t\tconst requestStartTime = hrTimeHelper.get();\n\t\tconst method = request.method;\n\t\tconst uriPath = request.url;\n\t\tconst address = request.socket.remoteAddress;\n\t\tconst port = request.socket.remotePort;\n\n\t\tthis._eventBus.emit('trace', `Request to ${method} \"${uriPath}\" from ${address}:${port}`);\n\n\t\tresponse.on('finish', () => {\n\t\t\tconst requestDuration = hrTimeHelper.get(requestStartTime);\n\t\t\tconst timeMessage = hrTimeHelper.toMessage(requestDuration);\n\n\t\t\tthis._eventBus.emit('trace', `Response from ${method} \"${uriPath}\" to ${address}:${port} (${timeMessage})`);\n\t\t});\n\n\t\tthis._documentRenderer.render(state, routingContext);\n\t}\n}\n\nmodule.exports = RequestRouter;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/ContextFactory.js":"'use strict';\n\nconst propertyHelper = require('./helpers/propertyHelper');\n\nclass ContextFactory {\n\n\t/**\n\t * Creates a new instance of the context factory.\n\t * @param {ServiceLocator} locator Locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\n\t\t/**\n\t\t * Current service locator.\n\t\t * @type {ServiceLocator}\n\t\t * @private\n\t\t */\n\t\tthis._serviceLocator = locator;\n\t}\n\n\t/**\n\t * Creates a new context for modules.\n\t * @param {Object} additional Additional parameters.\n\t * @param {URI} additional.referrer Current referrer.\n\t * @param {URI} additional.location Current location.\n\t * @param {string} additional.userAgent Current user agent.\n\t */\n\tcreate(additional) {\n\t\tconst apiProvider = this._serviceLocator.resolve('moduleApiProvider');\n\t\tconst context = Object.create(apiProvider);\n\t\tObject.keys(additional)\n\t\t\t.forEach(key => propertyHelper.defineReadOnly(context, key, additional[key]));\n\t\treturn context;\n\t}\n}\n\nmodule.exports = ContextFactory;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/Catberry.js":"'use strict';\n\nconst CatberryBase = require('./base/CatberryBase');\n\nclass Catberry extends CatberryBase {\n\n\t/**\n\t * Creates a new instance of the server-side Catberry.\n\t */\n\tconstructor() {\n\t\tsuper();\n\n\t\t/**\n\t\t * Current request router.\n\t\t * @type {RequestRouter}\n\t\t * @private\n\t\t */\n\t\tthis._router = null;\n\t}\n\n\t/**\n\t * Gets the connect/express middleware.\n\t * @returns {Function} Middleware function.\n\t */\n\tgetMiddleware() {\n\t\tthis._router = this.locator.resolve('requestRouter');\n\t\treturn this._router.route.bind(this._router);\n\t}\n\n\t/**\n\t * Builds the browser bundle.\n\t * @returns {Promise} Promise for nothing.\n\t */\n\tbuild() {\n\t\tconst builder = this.locator.resolve('browserBundleBuilder');\n\t\treturn builder.build();\n\t}\n}\n\nmodule.exports = Catberry;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/base/CatberryBase.js":"'use strict';\n\nconst ServiceLocator = require('catberry-locator');\n\n/**\n * Implements the basic Catberry class for both server and browser environments.\n */\nclass CatberryBase {\n\n\t/**\n\t * Creates a new instance of the basic Catberry application module.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * Current service locator.\n\t\t * @type {ServiceLocator}\n\t\t */\n\t\tthis.locator = new ServiceLocator();\n\n\t\t/**\n\t\t * Current version of Catberry.\n\t\t */\n\t\tthis.version = '9.0.0';\n\n\t\t/**\n\t\t * Current object with events.\n\t\t * @type {ModuleApiProvider}\n\t\t */\n\t\tthis.events = null;\n\n\t\tthis.locator.registerInstance('serviceLocator', this.locator);\n\t\tthis.locator.registerInstance('catberry', this);\n\t}\n}\n\nmodule.exports = CatberryBase;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry-locator/lib/ServiceLocator.js":"'use strict';\n\n/**\n * Implements a Service Locator pattern.\n */\nclass ServiceLocator {\n\n\t/**\n\t * Creates a new instance of the service locator class.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * Current type registrations.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._registrations = Object.create(null);\n\t}\n\n\t/**\n\t * Registers a new type name in the service locator.\n\t * @param {string} type The type name used as a key for resolving instances.\n\t * @param {Function} implementation The implementation (constructor or class)\n\t * which creates instances of the specified type name.\n\t * @param {boolean?} isSingleton If true then the only instance will\n\t * be created on the first \"resolve\" call and next calls will\n\t * return this instance.\n\t */\n\tregister(type, implementation, isSingleton) {\n\t\tthis._throwIfNotFunction(type, implementation);\n\t\tthis._throwIfNotString(type);\n\n\t\tthis._initializeRegistration(type);\n\n\t\tthis._registrations[type].unshift({\n\t\t\tImplementation: implementation,\n\t\t\tisSingleton: Boolean(isSingleton),\n\t\t\tsingleInstance: null\n\t\t});\n\t}\n\n\t/**\n\t * Registers a single instance for the specified type.\n\t * @param {string} type The type name for resolving the instance.\n\t * @param {Object} instance The instance to register.\n\t */\n\tregisterInstance(type, instance) {\n\t\tthis._throwIfNotString(type);\n\t\tthis._initializeRegistration(type);\n\n\t\tthis._registrations[type].unshift({\n\t\t\tImplementation: instance.constructor,\n\t\t\tisSingleton: true,\n\t\t\tsingleInstance: instance\n\t\t});\n\t}\n\n\t/**\n\t * Resolves the last registered implementation by the type name.\n\t * @param {string} type The type name to resolve.\n\t * @returns {Object} The instance of the specified type name.\n\t */\n\tresolve(type) {\n\t\tthis._throwIfNotString(type);\n\t\tthis._throwIfNoType(type);\n\t\tconst firstRegistration = this._registrations[type][0];\n\t\treturn this._createInstance(firstRegistration);\n\t}\n\n\t/**\n\t * Resolves all registered implementations by the type name.\n\t * @param {string} type The type name for resolving instances.\n\t * @returns {Array} The list of instances of the specified type name.\n\t */\n\tresolveAll(type) {\n\t\tthis._throwIfNotString(type);\n\t\tthis._throwIfNoType(type);\n\t\treturn this._registrations[type]\n\t\t\t.map(registration => this._createInstance(registration));\n\t}\n\n\t/**\n\t * Unregisters all registrations of the specified type name.\n\t * @param {string} type The type name for deleting the registrations.\n\t */\n\tunregister(type) {\n\t\tthis._throwIfNotString(type);\n\t\tthis._registrations[type] = [];\n\t}\n\n\t/**\n\t * The function checks whether a type exists and if there is at least one instance\n\t *\n\t * @param {string} type The type name\n\t * @returns {boolean}\n\t */\n\thas(type) {\n\t\tthis._throwIfNotString(type);\n\n\t\treturn (type in this._registrations && this._registrations[type].length > 0);\n\t}\n\n\t/**\n\t * Creates an instance for the specified registration descriptor.\n\t * @param {Object} registration The registration descriptor object.\n\t * @returns {Object} The instance of the implementation found in\n\t * the specified registration descriptor.\n\t */\n\t_createInstance(registration) {\n\t\tif (registration.isSingleton && registration.singleInstance !== null) {\n\t\t\treturn registration.singleInstance;\n\t\t}\n\n\t\t// inject Service Locator as the only argument of the constructor.\n\t\tconst instance = new registration.Implementation(this);\n\n\t\tif (registration.isSingleton) {\n\t\t\tregistration.singleInstance = instance;\n\t\t}\n\n\t\treturn instance;\n\t}\n\n\t/**\n\t * Initializes a registration list for the specified type name.\n\t * @param {string} type The type name for the registration list.\n\t * @private\n\t */\n\t_initializeRegistration(type) {\n\t\tif (type in this._registrations) {\n\t\t\treturn;\n\t\t}\n\t\tthis._registrations[type] = [];\n\t}\n\n\t/**\n\t * Throws an error if the specified registration is not found.\n\t * @param {string} type The type name to check.\n\t * @private\n\t */\n\t_throwIfNoType(type) {\n\t\tif (type in this._registrations &&\n\t\t\tthis._registrations[type].length > 0) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`Type \"${type}\" not registered`);\n\t}\n\n\t/**\n\t * Throws an error if the specified implementation is not a function.\n\t * @param {string} type The type name of the implementation.\n\t * @param {Function} Implementation The implementation to check.\n\t * @private\n\t */\n\t_throwIfNotFunction(type, Implementation) {\n\t\tif (Implementation instanceof Function) {\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error(`Constructor for type ${type} should be a function`);\n\t}\n\n\t/**\n\t * Throws an error if the specified type name is not a string.\n\t * @param {string} type Type name to check.\n\t */\n\t_throwIfNotString(type) {\n\t\tif (typeof (type) === 'string') {\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error(`Type name \"${type}\" should be a string`);\n\t}\n}\n\nmodule.exports = ServiceLocator;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/browser/Bootstrapper.js":"'use strict';\n\nconst Catberry = require('./Catberry.js');\nconst BootstrapperBase = require('../lib/base/BootstrapperBase');\nconst StoreDispatcher = require('../lib/StoreDispatcher');\nconst ModuleApiProvider = require('./providers/ModuleApiProvider');\nconst CookieWrapper = require('./CookieWrapper');\n\nclass Bootstrapper extends BootstrapperBase {\n\n\t/**\n\t * Creates a new instance of the browser Catberry's bootstrapper.\n\t */\n\tconstructor() {\n\t\tsuper(Catberry);\n\t}\n\n\t/**\n\t * Configures a Catberry's service locator.\n\t * @param {Object} configObject The application config object.\n\t * @param {ServiceLocator} locator The service locator to configure.\n\t */\n\tconfigure(configObject, locator) {\n\t\tsuper.configure(configObject, locator);\n\n\t\tlocator.register('storeDispatcher', StoreDispatcher, true);\n\t\tlocator.register('moduleApiProvider', ModuleApiProvider, true);\n\t\tlocator.register('cookieWrapper', CookieWrapper, true);\n\n\t\tlocator.registerInstance('window', window);\n\t}\n}\n\nmodule.exports = new Bootstrapper();\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/browser/Catberry.js":"'use strict';\n\nconst CatberryBase = require('../lib/base/CatberryBase');\n\nconst Promise = require('promise');\n// if browser still does not have promises then add it.\nif (!('Promise' in window)) {\n\twindow.Promise = Promise;\n}\n\nclass Catberry extends CatberryBase {\n\n\t/**\n\t * Creates new instance of the browser version of Catberry.\n\t */\n\tconstructor() {\n\t\tsuper();\n\n\t\t/**\n\t\t * Current request router.\n\t\t * @type {RequestRouter}\n\t\t * @private\n\t\t */\n\t\tthis._router = null;\n\t}\n\n\t/**\n\t * Wraps current HTML document with Catberry event handlers.\n\t */\n\twrapDocument() {\n\t\tconst appDefinitions = require('appDefinitions');\n\t\tappDefinitions.routeDefinitions\n\t\t\t.forEach(routeDefinition => this.locator.registerInstance('routeDefinition', routeDefinition));\n\n\t\tappDefinitions.routeDescriptors\n\t\t\t.forEach(routeDescriptor => this.locator.registerInstance('routeDescriptor', routeDescriptor));\n\n\t\tappDefinitions.stores\n\t\t\t.forEach(store => this.locator.registerInstance('store', store));\n\n\t\tappDefinitions.components\n\t\t\t.forEach(component => this.locator.registerInstance('component', component));\n\n\t\tthis._router = this.locator.resolve('requestRouter');\n\t}\n\n\t/**\n\t * Starts Catberry application when DOM is ready.\n\t * @returns {Promise} Promise for nothing.\n\t */\n\tstartWhenReady() {\n\t\tif (window.catberry) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn new Promise((fulfill, reject) => {\n\t\t\twindow.document.addEventListener('DOMContentLoaded', () => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.wrapDocument();\n\t\t\t\t\twindow.catberry = this;\n\t\t\t\t\tfulfill();\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\nmodule.exports = Catberry;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/browser/CookieWrapper.js":"'use strict';\n\nconst CookieWrapperBase = require('../lib/base/CookieWrapperBase');\n\nclass CookieWrapper extends CookieWrapperBase {\n\n\t/**\n\t * Creates a new instance of the browser cookie wrapper.\n\t * @param {ServiceLocator} locator The service locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Current browser window.\n\t\t * @type {Window}\n\t\t * @private\n\t\t */\n\t\tthis._window = locator.resolve('window');\n\t}\n\n\t/**\n\t * Gets current cookie string.\n\t * @returns {string} Cookie string.\n\t */\n\tgetCookieString() {\n\t\treturn this._window.document.cookie ?\n\t\t\tthis._window.document.cookie.toString() :\n\t\t\t'';\n\t}\n\n\t/**\n\t * Sets cookie to this wrapper.\n\t * @param {Object} cookieSetup Cookie setup object.\n\t * @param {string} cookieSetup.key Cookie key.\n\t * @param {string} cookieSetup.value Cookie value.\n\t * @param {number?} cookieSetup.maxAge Max cookie age in seconds.\n\t * @param {Date?} cookieSetup.expires Expire date.\n\t * @param {string?} cookieSetup.path URI path for cookie.\n\t * @param {string?} cookieSetup.domain Cookie domain.\n\t * @param {boolean?} cookieSetup.secure Is cookie secured.\n\t * @param {boolean?} cookieSetup.httpOnly Is cookie HTTP only.\n\t * @returns {string} Cookie setup string.\n\t */\n\tset(cookieSetup) {\n\t\tconst cookie = this._convertToCookieSetup(cookieSetup);\n\t\tthis._window.document.cookie = cookie;\n\t\treturn cookie;\n\t}\n}\n\nmodule.exports = CookieWrapper;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/browser/DocumentRenderer.js":"'use strict';\n\nconst morphdom = require('morphdom');\nconst uuid = require('uuid');\nconst errorHelper = require('../lib/helpers/errorHelper');\nconst moduleHelper = require('../lib/helpers/moduleHelper');\nconst hrTimeHelper = require('../lib/helpers/hrTimeHelper');\nconst DocumentRendererBase = require('../lib/base/DocumentRendererBase');\n\nconst SPECIAL_IDS = {\n\t$$head: '$$head',\n\t$$document: '$$document'\n};\nconst TAG_NAMES = {\n\tHEAD: 'HEAD',\n\tSTYLE: 'STYLE',\n\tSCRIPT: 'SCRIPT',\n\tLINK: 'LINK'\n};\n\n// http://www.w3.org/TR/2015/WD-uievents-20150319/#event-types-list\nconst NON_BUBBLING_EVENTS = {\n\tabort: true,\n\tblur: true,\n\terror: true,\n\tfocus: true,\n\tload: true,\n\tmouseenter: true,\n\tmouseleave: true,\n\tresize: true,\n\tunload: true\n};\n\nclass DocumentRenderer extends DocumentRendererBase {\n\n\t/**\n\t * Creates a new instance of the document renderer.\n\t * @param {ServiceLocator} locator Locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\t\tsuper(locator);\n\n\t\t/**\n\t\t * Current set of component instances by unique keys.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._componentInstances = Object.create(null);\n\n\t\t/**\n\t\t * Current set of component elements by unique keys.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._componentElements = Object.create(null);\n\n\t\t/**\n\t\t * Current set of component bindings by unique keys.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._componentBindings = Object.create(null);\n\n\t\t/**\n\t\t * Current set of changed stores.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._currentChangedStores = Object.create(null);\n\n\t\t/**\n\t\t * Current browser's window.\n\t\t */\n\t\tthis._window = locator.resolve('window');\n\n\t\t/**\n\t\t * Current application config.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._config = locator.resolve('config');\n\n\t\t/**\n\t\t * Current store dispatcher.\n\t\t * @type {StoreDispatcher}\n\t\t * @protected\n\t\t */\n\t\tthis._storeDispatcher = locator.resolve('storeDispatcher');\n\n\t\t/**\n\t\t * Current promise for rendered page.\n\t\t * @type {Promise}\n\t\t * @private\n\t\t */\n\t\tthis._renderedPromise = null;\n\n\t\t/**\n\t\t * Current state of updating components.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._isUpdating = false;\n\n\t\t/**\n\t\t * Current awaiting routing.\n\t\t * @type {{state: Object, routingContext: Object}}\n\t\t * @private\n\t\t */\n\t\tthis._awaitingRouting = null;\n\n\t\t/**\n\t\t * Current routing context.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._currentRoutingContext = null;\n\n\t\tthis._eventBus.on('storeChanged', storeName => {\n\t\t\tthis._currentChangedStores[storeName] = true;\n\t\t\tif (this._isStateChanging) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._updateStoreComponents();\n\t\t});\n\t}\n\n\t/**\n\t * Sets the initial state of the application.\n\t * @param {Object} state New state of the application.\n\t * @param {Object} routingContext Routing context.\n\t * @returns {Promise} Promise for nothing.\n\t */\n\tinitWithState(state, routingContext) {\n\t\treturn this._getPromiseForReadyState()\n\t\t\t.then(() => {\n\t\t\t\tthis._currentRoutingContext = routingContext;\n\t\t\t\treturn this._storeDispatcher.setState(state, routingContext);\n\t\t\t})\n\t\t\t.then(() => {\n\t\t\t\tconst components = this._componentLoader.getComponentsByNames();\n\t\t\t\tconst documentElement = this._window.document.documentElement;\n\t\t\t\tconst action = element => this._initializeComponent(element, components);\n\t\t\t\treturn this._traverseComponents([documentElement], components, action);\n\t\t\t})\n\t\t\t.then(() => this._eventBus.emit(\n\t\t\t\t'documentRendered', this._currentRoutingContext\n\t\t\t));\n\t}\n\n\t/**\n\t * Renders a new state of the application.\n\t * @param {Object} state New state of the application.\n\t * @param {Object} routingContext Routing context.\n\t * @returns {Promise} Promise for nothing.\n\t */\n\trender(state, routingContext) {\n\t\tthis._awaitingRouting = {\n\t\t\tstate,\n\t\t\troutingContext\n\t\t};\n\t\tif (this._isStateChanging) {\n\t\t\treturn this._renderedPromise;\n\t\t}\n\n\t\t// we should set this flag to avoid \"storeChanged\"\n\t\t// event handling for now\n\t\tthis._isStateChanging = true;\n\n\t\tthis._renderedPromise = this._getPromiseForReadyState()\n\t\t\t// and then we update all components of these stores in a batch.\n\t\t\t.then(() => this._updateStoreComponents())\n\t\t\t.catch(reason => this._eventBus.emit('error', reason))\n\t\t\t.then(() => {\n\t\t\t\tthis._isStateChanging = false;\n\t\t\t});\n\n\t\treturn this._renderedPromise;\n\t}\n\n\t/**\n\t * Renders a component into the HTML element.\n\t * @param {Element} element HTML element of the component.\n\t * @param {Object?} renderingContext Rendering context for group rendering.\n\t */\n\trenderComponent(element, renderingContext) {\n\t\treturn this._getPromiseForReadyState()\n\t\t\t.then(() => {\n\t\t\t\tconst id = this._getId(element);\n\t\t\t\tconst componentName = moduleHelper.getOriginalComponentName(element.tagName);\n\n\t\t\t\tif (!renderingContext) {\n\t\t\t\t\trenderingContext = this._createRenderingContext([]);\n\t\t\t\t\trenderingContext.rootIds[id] = true;\n\t\t\t\t}\n\n\t\t\t\tconst hadChildren = (element.children.length > 0);\n\t\t\t\tconst component = renderingContext.components[componentName];\n\t\t\t\tif (!component) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\trenderingContext.renderedIds[id] = true;\n\n\t\t\t\tlet instance = this._componentInstances[id];\n\t\t\t\tif (!instance) {\n\t\t\t\t\tcomponent.constructor.prototype.$context =\n\t\t\t\t\t\tthis._getComponentContext(component, element);\n\t\t\t\t\tinstance = new component.constructor(this._serviceLocator);\n\t\t\t\t\tinstance.$context = component.constructor.prototype.$context;\n\t\t\t\t\tthis._componentInstances[id] = instance;\n\t\t\t\t}\n\n\t\t\t\tconst eventArgs = {\n\t\t\t\t\tname: componentName,\n\t\t\t\t\tcontext: instance.$context\n\t\t\t\t};\n\n\t\t\t\tthis._componentElements[id] = element;\n\n\t\t\t\tconst startTime = hrTimeHelper.get();\n\t\t\t\tthis._eventBus.emit('componentRender', eventArgs);\n\n\t\t\t\treturn Promise.resolve()\n\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t// we need unbind the whole hierarchy only at\n\t\t\t\t\t\t// the beginning and not for new elements\n\t\t\t\t\t\tif (!(id in renderingContext.rootIds) || !hadChildren) {\n\t\t\t\t\t\t\treturn [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn this._unbindAll(element, renderingContext);\n\t\t\t\t\t})\n\t\t\t\t\t.catch(reason => this._eventBus.emit('error', reason))\n\t\t\t\t\t.then(() => {\n\t\t\t\t\t\tconst renderMethod = moduleHelper.getMethodToInvoke(instance, 'render');\n\t\t\t\t\t\treturn moduleHelper.getSafePromise(renderMethod);\n\t\t\t\t\t})\n\t\t\t\t\t.then(dataContext => component.template.render(dataContext))\n\t\t\t\t\t.catch(reason => this._handleRenderError(element, component, reason))\n\t\t\t\t\t.then(html => {\n\t\t\t\t\t\tconst isHead = element.tagName === TAG_NAMES.HEAD;\n\t\t\t\t\t\tif (html === '' && isHead) {\n\t\t\t\t\t\t\treturn [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst tmpElement = element.cloneNode(false);\n\t\t\t\t\t\ttmpElement.innerHTML = html;\n\n\t\t\t\t\t\tif (isHead) {\n\t\t\t\t\t\t\tthis._mergeHead(element, tmpElement);\n\t\t\t\t\t\t\treturn [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmorphdom(element, tmpElement, {\n\t\t\t\t\t\t\tonBeforeElChildrenUpdated: foundElement =>\n\t\t\t\t\t\t\t\tfoundElement === element || !this._isComponentElement(\n\t\t\t\t\t\t\t\t\trenderingContext.components, foundElement\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst promises = this._findNestedComponents(\n\t\t\t\t\t\t\telement, renderingContext.components\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map(child => this.renderComponent(child, renderingContext));\n\n\t\t\t\t\t\treturn Promise.all(promises);\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => {\n\t\t\t\t\t\teventArgs.hrTime = hrTimeHelper.get(startTime);\n\t\t\t\t\t\teventArgs.time = hrTimeHelper.toMilliseconds(eventArgs.hrTime);\n\t\t\t\t\t\tthis._eventBus.emit('componentRendered', eventArgs);\n\t\t\t\t\t\treturn this._bindComponent(element);\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t// collecting garbage only when\n\t\t\t\t\t\t// the entire rendering is finished\n\t\t\t\t\t\tif (!(id in renderingContext.rootIds) || !hadChildren) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._collectRenderingGarbage(renderingContext);\n\t\t\t\t\t})\n\t\t\t\t\t.catch(reason => this._eventBus.emit('error', reason));\n\t\t\t});\n\t}\n\n\t/**\n\t * Gets a component instance by ID.\n\t * @param {string} id Component's element ID.\n\t * @returns {Object|null} Component instance.\n\t */\n\tgetComponentById(id) {\n\t\tconst element = this._window.document.getElementById(id);\n\t\treturn this.getComponentByElement(element);\n\t}\n\n\t/**\n\t * Does query for a component by the selector.\n\t * @param {string} selector Selector for the query.\n\t * @param {Object?} parentComponent Parent component object.\n\t * @returns {Object} The found component object.\n\t */\n\tqueryComponentSelector(selector, parentComponent) {\n\t\tconst parent = this._isComponentObject(parentComponent) ?\n\t\t\tparentComponent.$context.element : this._window.document;\n\t\treturn this.getComponentByElement(parent.querySelector(selector));\n\t}\n\n\t/**\n\t * Does query for all components by the selector.\n\t * @param {string} selector Selector for the query.\n\t * @param {Object?} parentComponent Parent component object.\n\t * @returns {Array} The found component object list.\n\t */\n\tqueryComponentSelectorAll(selector, parentComponent) {\n\t\tconst parent = this._isComponentObject(parentComponent) ?\n\t\t\tparentComponent.$context.element : this._window.document;\n\t\treturn this._mapElementsToComponents(parent.querySelectorAll(selector));\n\t}\n\n\t/**\n\t * Gets all components by the tag name.\n\t * @param {string} tagName Tag name of the components.\n\t * @param {Object?} parentComponent Parent component object.\n\t * @returns {Array} The found component object list.\n\t */\n\tgetComponentsByTagName(tagName, parentComponent) {\n\t\tconst parent = this._isComponentObject(parentComponent) ?\n\t\t\tparentComponent.$context.element : this._window.document;\n\t\treturn this._mapElementsToComponents(parent.getElementsByTagName(tagName));\n\t}\n\n\t/**\n\t * Gets all components by the class name.\n\t * @param {string} className Class name of the components.\n\t * @param {Object?} parentComponent Parent component object.\n\t * @returns {Array} The found component object list.\n\t */\n\tgetComponentsByClassName(className, parentComponent) {\n\t\tconst parent = this._isComponentObject(parentComponent) ?\n\t\t\tparentComponent.$context.element : this._window.document;\n\t\treturn this._mapElementsToComponents(parent.getElementsByClassName(className));\n\t}\n\n\t/**\n\t * Gets component instance by a DOM element.\n\t * @param {Element} element Component's Element.\n\t * @returns {Object|null} Component instance.\n\t */\n\tgetComponentByElement(element) {\n\t\tif (!element) {\n\t\t\treturn null;\n\t\t}\n\t\tconst id = element[moduleHelper.COMPONENT_ID];\n\t\tif (!id) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._componentInstances[id] || null;\n\t}\n\n\t/**\n\t * Checks that every instance of the component has an element on the page and\n\t * removes all references to those components which were removed from DOM.\n\t * @returns {Promise} Promise for nothing.\n\t */\n\t/* eslint max-nested-callbacks: 0 */\n\tcollectGarbage() {\n\t\treturn this._getPromiseForReadyState()\n\t\t\t.then(() => {\n\t\t\t\tconst context = {\n\t\t\t\t\troots: [],\n\t\t\t\t\tcomponents: this._componentLoader.getComponentsByNames()\n\t\t\t\t};\n\n\t\t\t\tObject.keys(this._componentElements)\n\t\t\t\t\t.forEach(id => {\n\t\t\t\t\t\t// we should not remove special elements like HEAD\n\t\t\t\t\t\tif (SPECIAL_IDS.hasOwnProperty(id)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet current = this._componentElements[id];\n\t\t\t\t\t\twhile (current !== this._window.document.documentElement) {\n\t\t\t\t\t\t\t// the component is situated in a detached DOM subtree\n\t\t\t\t\t\t\tif (current.parentElement === null) {\n\t\t\t\t\t\t\t\tcontext.roots.push(current);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// the component is another component's descendant\n\t\t\t\t\t\t\tif (this._isComponentElement(context.components, current.parentElement)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrent = current.parentElement;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\treturn this._removeDetachedComponents(context);\n\t\t\t});\n\t}\n\n\t/**\n\t * Creates and renders a component element.\n\t * @param {string} tagName Name of the HTML tag.\n\t * @param {Object?} attributes Element attributes.\n\t * @returns {Promise<Element>} Promise for HTML element with the rendered component.\n\t */\n\tcreateComponent(tagName, attributes) {\n\t\tif (typeof (tagName) !== 'string') {\n\t\t\treturn Promise.reject(\n\t\t\t\tnew Error('The tag name must be a string')\n\t\t\t);\n\t\t}\n\t\tattributes = attributes || Object.create(null);\n\n\t\treturn this._getPromiseForReadyState()\n\t\t\t.then(() => {\n\t\t\t\tconst components = this._componentLoader.getComponentsByNames();\n\t\t\t\tconst componentName = moduleHelper.getOriginalComponentName(tagName);\n\n\t\t\t\tif (moduleHelper.isHeadComponent(componentName) ||\n\t\t\t\t\tmoduleHelper.isDocumentComponent(componentName) ||\n\t\t\t\t\t!(componentName in components)) {\n\t\t\t\t\treturn Promise.reject(new Error(`Component for tag \"${tagName}\" not found`));\n\t\t\t\t}\n\n\t\t\t\tconst safeTagName = moduleHelper.getTagNameForComponentName(componentName);\n\t\t\t\tconst element = this._window.document.createElement(safeTagName);\n\t\t\t\tObject.keys(attributes)\n\t\t\t\t\t.forEach(attributeName => element.setAttribute(attributeName, attributes[attributeName]));\n\n\t\t\t\treturn this.renderComponent(element)\n\t\t\t\t\t.then(() => element);\n\t\t\t});\n\t}\n\n\t/**\n\t * Clears all references to removed components during the rendering process.\n\t * @param {Object} renderingContext Context of rendering.\n\t * @private\n\t */\n\t_collectRenderingGarbage(renderingContext) {\n\t\tObject.keys(renderingContext.unboundIds)\n\t\t\t.forEach(id => {\n\t\t\t\t// this component has been rendered again and we do not need to\n\t\t\t\t// remove it.\n\t\t\t\tif (id in renderingContext.renderedIds) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._removeComponentById(id);\n\t\t\t});\n\t}\n\n\t/**\n\t * Removes detached subtrees from the components set.\n\t * @param {{roots: Array, components: Object}} context Operation context.\n\t * @returns {Promise} Promise for finished removal\n\t * @private\n\t */\n\t_removeDetachedComponents(context) {\n\t\tif (context.roots.length === 0) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tconst root = context.roots.pop();\n\t\treturn this._traverseComponents([root], context.components, element => this._removeDetachedComponent(element))\n\t\t\t.then(() => this._removeDetachedComponents(context));\n\t}\n\n\t/**\n\t * Removes detached component.\n\t * @param {Element} element Element of the detached component.\n\t * @returns {Promise} Promise for the removed component.\n\t * @private\n\t */\n\t_removeDetachedComponent(element) {\n\t\tconst id = this._getId(element);\n\t\treturn this._unbindComponent(element)\n\t\t\t.then(() => this._removeComponentById(id));\n\t}\n\n\t/**\n\t * Unbinds all event handlers from the specified component and all it's descendants.\n\t * @param {Element} element Component HTML element.\n\t * @param {Object} renderingContext Context of rendering.\n\t * @returns {Promise} Promise for nothing.\n\t * @private\n\t */\n\t_unbindAll(element, renderingContext) {\n\t\tconst action = innerElement => {\n\t\t\tconst id = this._getId(innerElement);\n\t\t\trenderingContext.unboundIds[id] = true;\n\t\t\treturn this._unbindComponent(innerElement);\n\t\t};\n\t\treturn this._traverseComponents([element], renderingContext.components, action);\n\t}\n\n\t/**\n\t * Unbinds all event handlers from the specified component.\n\t * @param {Element} element Component HTML element.\n\t * @returns {Promise} Promise for nothing.\n\t * @private\n\t */\n\t_unbindComponent(element) {\n\t\tconst id = this._getId(element);\n\t\tconst instance = this._componentInstances[id];\n\n\t\tif (!instance) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tif (id in this._componentBindings) {\n\t\t\tObject.keys(this._componentBindings[id])\n\t\t\t\t.forEach(eventName => {\n\t\t\t\t\telement.removeEventListener(\n\t\t\t\t\t\teventName,\n\t\t\t\t\t\tthis._componentBindings[id][eventName].handler,\n\t\t\t\t\t\tNON_BUBBLING_EVENTS.hasOwnProperty(eventName)\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\tdelete this._componentBindings[id];\n\t\t}\n\n\t\tconst unbindMethod = moduleHelper.getMethodToInvoke(instance, 'unbind');\n\t\treturn moduleHelper.getSafePromise(unbindMethod)\n\t\t\t.then(() => {\n\t\t\t\tthis._eventBus.emit('componentUnbound', {\n\t\t\t\t\telement,\n\t\t\t\t\tid: element.id || null\n\t\t\t\t});\n\t\t\t})\n\t\t\t.catch(reason => this._eventBus.emit('error', reason));\n\t}\n\n\t/**\n\t * Removes a component from the current list.\n\t * @param {string} id Component's ID\n\t * @private\n\t */\n\t_removeComponentById(id) {\n\t\tdelete this._componentElements[id];\n\t\tdelete this._componentInstances[id];\n\t\tdelete this._componentBindings[id];\n\t}\n\n\t/**\n\t * Binds all required event handlers to the component.\n\t * @param {Element} element Component's HTML element.\n\t * @returns {Promise} Promise for nothing.\n\t * @private\n\t */\n\t_bindComponent(element) {\n\t\tconst id = this._getId(element);\n\t\tconst instance = this._componentInstances[id];\n\t\tif (!instance) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tconst bindMethod = moduleHelper.getMethodToInvoke(instance, 'bind');\n\t\treturn moduleHelper.getSafePromise(bindMethod)\n\t\t\t.then(bindings => {\n\t\t\t\tif (!bindings || typeof (bindings) !== 'object') {\n\t\t\t\t\tthis._eventBus.emit('componentBound', {\n\t\t\t\t\t\telement,\n\t\t\t\t\t\tid: element.id || null\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._componentBindings[id] = Object.create(null);\n\t\t\t\tObject.keys(bindings)\n\t\t\t\t\t.forEach(eventName => {\n\t\t\t\t\t\teventName = eventName.toLowerCase();\n\t\t\t\t\t\tif (eventName in this._componentBindings[id]) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst selectorHandlers = Object.create(null);\n\t\t\t\t\t\tObject.keys(bindings[eventName])\n\t\t\t\t\t\t\t.forEach(selector => {\n\t\t\t\t\t\t\t\tconst handler = bindings[eventName][selector];\n\t\t\t\t\t\t\t\tif (typeof (handler) !== 'function') {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tselectorHandlers[selector] = handler.bind(instance);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tthis._componentBindings[id][eventName] = {\n\t\t\t\t\t\t\thandler: this._createBindingHandler(element, selectorHandlers),\n\t\t\t\t\t\t\tselectorHandlers\n\t\t\t\t\t\t};\n\t\t\t\t\t\telement.addEventListener(\n\t\t\t\t\t\t\teventName,\n\t\t\t\t\t\t\tthis._componentBindings[id][eventName].handler,\n\t\t\t\t\t\t\tNON_BUBBLING_EVENTS.hasOwnProperty(eventName)\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\tthis._eventBus.emit('componentBound', {\n\t\t\t\t\telement,\n\t\t\t\t\tid: element.id || null\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\t/**\n\t * Creates a universal event handler for delegated events.\n\t * @param {Element} componentRoot Root element of the component.\n\t * @param {Object} selectorHandlers Map of event handlers by their CSS selectors.\n\t * @returns {Function} Universal event handler for delegated events.\n\t * @private\n\t */\n\t_createBindingHandler(componentRoot, selectorHandlers) {\n\t\tconst selectors = Object.keys(selectorHandlers);\n\t\treturn event => {\n\t\t\tvar element = event.target;\n\t\t\tconst dispatchedEvent = createCustomEvent(event, () => element);\n\t\t\tvar targetMatches = this._getMatchesMethod(element);\n\t\t\tvar isHandled = selectors.some(selector => {\n\t\t\t\tif (targetMatches(selector)) {\n\t\t\t\t\tselectorHandlers[selector](dispatchedEvent);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\n\t\t\tif (isHandled || !event.bubbles) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// we can't use parentElement here, because\n\t\t\t// internal SVG elements don't have this property in IE\n\t\t\twhile (element.parentNode && element !== componentRoot) {\n\t\t\t\telement = element.parentNode;\n\t\t\t\ttargetMatches = this._getMatchesMethod(element);\n\t\t\t\tisHandled = this._tryDispatchEvent(\n\t\t\t\t\tselectors, targetMatches, selectorHandlers, dispatchedEvent\n\t\t\t\t);\n\t\t\t\tif (isHandled) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Tries to dispatch an event.\n\t * @param {Array} selectors The list of supported selectors.\n\t * @param {Function} matchPredicate The function to check if selector matches.\n\t * @param {Object} handlers The set of handlers for events.\n\t * @param {Event} event The DOM event object.\n\t * @private\n\t */\n\t_tryDispatchEvent(selectors, matchPredicate, handlers, event) {\n\t\treturn selectors.some(selector => {\n\t\t\tif (!matchPredicate(selector)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\thandlers[selector](event);\n\t\t\treturn true;\n\t\t});\n\t}\n\n\t/**\n\t * Checks if the element is a component.\n\t * @param {Object} components Current components.\n\t * @param {Element} element DOM element.\n\t * @private\n\t */\n\t_isComponentElement(components, element) {\n\t\tif (!moduleHelper.isComponentNode(element)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn moduleHelper.getOriginalComponentName(element.nodeName) in components;\n\t}\n\n\t/**\n\t * Checks if the specified object is a component.\n\t * @param {Object} obj The component object.\n\t * @returns {boolean}\n\t * @private\n\t */\n\t_isComponentObject(obj) {\n\t\treturn obj && obj.$context &&\n\t\t\ttypeof (obj.$context) === 'object' &&\n\t\t\tobj.$context.element instanceof this._window.Element;\n\t}\n\n\t/**\n\t * Maps found elements to component objects filtering non-component elements.\n\t * @param {HTMLCollection|NodeList} elements Elements collection.\n\t * @returns {Array} Array of the component objects.\n\t * @private\n\t */\n\t_mapElementsToComponents(elements) {\n\t\tconst results = [];\n\t\tArray.prototype.forEach\n\t\t\t.call(elements, element => {\n\t\t\t\tconst component = this.getComponentByElement(element);\n\t\t\t\tif (component) {\n\t\t\t\t\tresults.push(component);\n\t\t\t\t}\n\t\t\t});\n\t\treturn results;\n\t}\n\n\t/**\n\t * Does asynchronous traversal through the components hierarchy.\n\t * @param {Array} elements Elements to start the search.\n\t * @param {Object} components Current set of components.\n\t * @param {function} action Action for every component.\n\t * @returns {Promise} Promise for the finished traversal.\n\t * @private\n\t */\n\t_traverseComponents(elements, components, action) {\n\t\tif (elements.length === 0) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tconst root = elements.shift();\n\t\telements = elements.concat(this._findNestedComponents(root, components));\n\t\treturn this._traverseComponents(elements, components, action)\n\t\t\t.then(() => action(root));\n\t}\n\n\t/**\n\t * Finds all descendant components of the specified component root.\n\t * @param {Element} root Root component's HTML root to begin search with.\n\t * @param {Object} components Map of components by their names.\n\t * @private\n\t */\n\t_findNestedComponents(root, components) {\n\t\tconst elements = [];\n\t\tconst queue = [root];\n\n\t\t// does breadth-first search inside the root element\n\t\twhile (queue.length > 0) {\n\t\t\tconst currentChildren = queue.shift().children;\n\t\t\tif (!currentChildren) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tArray.prototype.forEach.call(currentChildren, currentChild => {\n\t\t\t\t// and they should be components\n\t\t\t\tif (!this._isComponentElement(components, currentChild)) {\n\t\t\t\t\tqueue.push(currentChild);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\telements.push(currentChild);\n\t\t\t});\n\t\t}\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Handles an error while rendering.\n\t * @param {Element} element Component's HTML element.\n\t * @param {Object} component Component's instance.\n\t * @param {Error} error Error to handle.\n\t * @returns {Promise<string>} Promise for HTML string.\n\t * @private\n\t */\n\t_handleRenderError(element, component, error) {\n\t\tthis._eventBus.emit('error', error);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() => {\n\t\t\t\t// do not corrupt existed HEAD when error occurs\n\t\t\t\tif (element.tagName === TAG_NAMES.HEAD) {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\n\t\t\t\tif (!this._config.isRelease && error instanceof Error) {\n\t\t\t\t\treturn errorHelper.prettyPrint(error, this._window.navigator.userAgent);\n\t\t\t\t} else if (component.errorTemplate) {\n\t\t\t\t\treturn component.errorTemplate.render(error);\n\t\t\t\t}\n\n\t\t\t\treturn '';\n\t\t\t})\n\t\t\t.catch(() => '');\n\t}\n\n\t/**\n\t * Updates all components that depend on the current set of changed stores.\n\t * @returns {Promise} Promise for nothing.\n\t * @private\n\t */\n\t_updateStoreComponents() {\n\t\tif (this._isUpdating) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\t// if document component is changed we should reload the page\n\t\tconst documentStore = this._window.document.documentElement.getAttribute(\n\t\t\tmoduleHelper.ATTRIBUTE_STORE\n\t\t);\n\t\tif (documentStore in this._currentChangedStores) {\n\t\t\tconst newLocation = this._currentRoutingContext.location.toString();\n\t\t\tif (newLocation === this._window.location.toString()) {\n\t\t\t\tthis._window.location.reload();\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t\tthis._window.location.assign(newLocation);\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tthis._isUpdating = true;\n\n\t\t// if we have awaiting routing we should apply state to the stores\n\t\tif (this._awaitingRouting) {\n\t\t\tconst components = this._componentLoader.getComponentsByNames();\n\t\t\tconst changedByState = this._storeDispatcher.setState(\n\t\t\t\tthis._awaitingRouting.state,\n\t\t\t\tthis._awaitingRouting.routingContext\n\t\t\t);\n\n\t\t\tchangedByState.forEach(name => {\n\t\t\t\tthis._currentChangedStores[name] = true;\n\t\t\t});\n\n\t\t\t// we should update contexts of the components with the new routing context\n\t\t\tthis._currentRoutingContext = this._awaitingRouting.routingContext;\n\t\t\tObject.keys(this._componentInstances)\n\t\t\t\t.forEach(id => {\n\t\t\t\t\tconst instance = this._componentInstances[id];\n\t\t\t\t\tinstance.$context = this._getComponentContext(\n\t\t\t\t\t\tcomponents[instance.$context.name],\n\t\t\t\t\t\tinstance.$context.element\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\tthis._awaitingRouting = null;\n\t\t}\n\n\t\tconst changedStores = Object.keys(this._currentChangedStores);\n\t\tif (changedStores.length === 0) {\n\t\t\tthis._isUpdating = false;\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tthis._currentChangedStores = Object.create(null);\n\n\t\tconst renderingContext = this._createRenderingContext(changedStores);\n\t\tconst promises = renderingContext.roots.map(root => {\n\t\t\trenderingContext.rootIds[this._getId(root)] = true;\n\t\t\treturn this.renderComponent(root, renderingContext);\n\t\t});\n\n\t\treturn Promise.all(promises)\n\t\t\t.catch(reason => this._eventBus.emit('error', reason))\n\t\t\t.then(() => {\n\t\t\t\tthis._isUpdating = false;\n\t\t\t\tthis._eventBus.emit('documentUpdated', changedStores);\n\t\t\t\treturn this._updateStoreComponents();\n\t\t\t});\n\t}\n\n\t/**\n\t * Merges new and existed head elements and applies only difference.\n\t * The problem here is that we can't re-create or change script and style tags,\n\t * because it causes blinking and JavaScript re-initialization. Therefore such\n\t * element must be immutable in the HEAD.\n\t * @param {Node} head HEAD DOM element.\n\t * @param {Node} newHead New HEAD element.\n\t * @private\n\t */\n\t_mergeHead(head, newHead) {\n\t\tif (!newHead) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst headSet = Object.create(null);\n\n\t\t// remove all nodes from the current HEAD except immutable ones\n\t\tfor (let i = 0; i < head.childNodes.length; i++) {\n\t\t\tconst current = head.childNodes[i];\n\t\t\tif (!isTagImmutable(current)) {\n\t\t\t\thead.removeChild(current);\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// we need to collect keys for immutable elements to handle\n\t\t\t// attributes reordering\n\t\t\theadSet[this._getElementKey(current)] = true;\n\t\t}\n\n\t\tfor (let i = 0; i < newHead.children.length; i++) {\n\t\t\tconst current = newHead.children[i];\n\t\t\tif (this._getElementKey(current) in headSet) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thead.appendChild(current);\n\t\t\t// when we append existing child to another parent it removes\n\t\t\t// the node from a previous parent\n\t\t\ti--;\n\t\t}\n\t}\n\n\t/**\n\t * Gets an unique element key using element's attributes and its content.\n\t * @param {Element} element HTML element.\n\t * @returns {string} Unique key for the element.\n\t * @private\n\t */\n\t_getElementKey(element) {\n\t\t// some immutable elements have several valuable attributes\n\t\t// these attributes define the element identity\n\t\tconst attributes = [];\n\n\t\tswitch (element.nodeName) {\n\t\t\tcase TAG_NAMES.LINK:\n\t\t\t\tattributes.push(`href=${element.getAttribute('href')}`);\n\t\t\t\tbreak;\n\t\t\tcase TAG_NAMES.SCRIPT:\n\t\t\t\tattributes.push(`src=${element.getAttribute('src')}`);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn `<${element.nodeName} ${attributes.sort().join(' ')}>${element.textContent}</${element.nodeName}>`;\n\t}\n\n\t/**\n\t * Initializes the element as a component.\n\t * @param {Element} element The component's element.\n\t * @param {Object} components Current set of components.\n\t * @returns {Promise} Promise for the done initialization.\n\t * @private\n\t */\n\t_initializeComponent(element, components) {\n\t\treturn Promise.resolve()\n\t\t\t.then(() => {\n\t\t\t\tconst componentName = moduleHelper.getOriginalComponentName(element.nodeName);\n\t\t\t\tif (!(componentName in components)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst id = this._getId(element);\n\t\t\t\tconst ComponentConstructor = components[componentName].constructor;\n\t\t\t\tComponentConstructor.prototype.$context = this._getComponentContext(\n\t\t\t\t\tcomponents[componentName], element\n\t\t\t\t);\n\n\t\t\t\tconst instance = new ComponentConstructor(this._serviceLocator);\n\t\t\t\tinstance.$context = ComponentConstructor.prototype.$context;\n\t\t\t\tthis._componentElements[id] = element;\n\t\t\t\tthis._componentInstances[id] = instance;\n\t\t\t\t// initialize the store of the component\n\t\t\t\tthis._storeDispatcher.getStore(\n\t\t\t\t\telement.getAttribute(moduleHelper.ATTRIBUTE_STORE)\n\t\t\t\t);\n\t\t\t\tthis._eventBus.emit('componentRendered', {\n\t\t\t\t\tname: componentName,\n\t\t\t\t\tattributes: instance.$context.attributes,\n\t\t\t\t\tcontext: instance.$context\n\t\t\t\t});\n\t\t\t\treturn this._bindComponent(element);\n\t\t\t});\n\t}\n\n\t/**\n\t * Gets a component context using the basic context.\n\t * @param {Object} component Component details.\n\t * @param {Element} element DOM element of the component.\n\t * @returns {Object} Component's context.\n\t * @private\n\t */\n\t_getComponentContext(component, element) {\n\t\tconst storeName = element.getAttribute(moduleHelper.ATTRIBUTE_STORE);\n\t\tconst componentContext = Object.create(this._currentRoutingContext);\n\n\t\t// initialize the store of the component\n\t\tthis._storeDispatcher.getStore(storeName);\n\n\t\tObject.defineProperties(componentContext, {\n\t\t\tname: {\n\t\t\t\tget: () => component.name,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tattributes: {\n\t\t\t\tget: () => attributesToObject(element.attributes),\n\t\t\t\tenumerable: true\n\t\t\t}\n\t\t});\n\n\t\tcomponentContext.element = element;\n\n\t\t// search methods\n\t\tcomponentContext.getComponentById =\n\t\t\tid => this.getComponentById(id);\n\n\t\tcomponentContext.getComponentByElement =\n\t\t\telement => this.getComponentByElement(element);\n\n\t\tcomponentContext.getComponentsByTagName =\n\t\t\t(tagName, parent) => this.getComponentsByTagName(tagName, parent);\n\n\t\tcomponentContext.getComponentsByClassName =\n\t\t\t(className, parent) => this.getComponentsByClassName(className, parent);\n\n\t\tcomponentContext.queryComponentSelector =\n\t\t\t(selector, parent) => this.queryComponentSelector(selector, parent);\n\n\t\tcomponentContext.queryComponentSelectorAll =\n\t\t\t(selector, parent) => this.queryComponentSelectorAll(selector, parent);\n\n\t\t// create/remove\n\t\tcomponentContext.createComponent = (tagName, attributes) =>\n\t\t\tthis.createComponent(tagName, attributes);\n\t\tcomponentContext.collectGarbage = () => this.collectGarbage();\n\n\t\t// store methods\n\t\tcomponentContext.getStoreData = () => {\n\t\t\tconst currentStoreName = element.getAttribute(moduleHelper.ATTRIBUTE_STORE);\n\t\t\treturn this._storeDispatcher.getStoreData(currentStoreName);\n\t\t};\n\t\tcomponentContext.sendAction = (name, args) => {\n\t\t\tconst currentStoreName = element.getAttribute(moduleHelper.ATTRIBUTE_STORE);\n\t\t\treturn this._storeDispatcher.sendAction(currentStoreName, name, args);\n\t\t};\n\n\t\treturn Object.freeze(componentContext);\n\t}\n\n\t/**\n\t * Finds all rendering roots on the page for all changed stores.\n\t * @param {Array} changedStoreNames List of changed store's names.\n\t * @returns {Array<Element>} HTML elements that are rendering roots.\n\t * @private\n\t */\n\t_findRenderingRoots(changedStoreNames) {\n\t\tconst headStore = this._window.document.head.getAttribute(moduleHelper.ATTRIBUTE_STORE);\n\t\tconst components = this._componentLoader.getComponentsByNames();\n\t\tconst componentElements = Object.create(null);\n\t\tconst storeNamesSet = Object.create(null);\n\t\tconst rootsSet = Object.create(null);\n\t\tconst roots = [];\n\n\t\t// we should find all components and then look for roots\n\t\tchangedStoreNames\n\t\t\t.forEach(storeName => {\n\t\t\t\tstoreNamesSet[storeName] = true;\n\t\t\t\tconst elements = this._window.document\n\t\t\t\t\t.querySelectorAll(`[${moduleHelper.ATTRIBUTE_STORE}=\"${storeName}\"]`);\n\t\t\t\tif (elements.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcomponentElements[storeName] = elements;\n\t\t\t});\n\n\t\tif (headStore in storeNamesSet && moduleHelper.HEAD_COMPONENT_NAME in components) {\n\t\t\trootsSet[this._getId(this._window.document.head)] = true;\n\t\t\troots.push(this._window.document.head);\n\t\t}\n\n\t\tchangedStoreNames\n\t\t\t.forEach(storeName => {\n\t\t\t\tif (!(storeName in componentElements)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// we can optimize and don't go the same path twice\n\t\t\t\tconst visitedIds = Object.create(null);\n\n\t\t\t\tArray.prototype.forEach.call(componentElements[storeName], current => {\n\t\t\t\t\tif (!moduleHelper.isComponentNode(current)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet currentRoot = current;\n\t\t\t\t\tlet lastRoot = currentRoot;\n\t\t\t\t\tlet lastRootId = this._getId(current);\n\t\t\t\t\tif (lastRootId in visitedIds) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvisitedIds[lastRootId] = true;\n\n\t\t\t\t\twhile (currentRoot.parentElement) {\n\t\t\t\t\t\tcurrentRoot = currentRoot.parentElement;\n\n\t\t\t\t\t\t// if we go the same route we visited before we can\n\t\t\t\t\t\t// proceed with the next element\n\t\t\t\t\t\tconst currentId = this._getId(currentRoot);\n\t\t\t\t\t\tif (currentId in visitedIds) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst currentStore = currentRoot.getAttribute(moduleHelper.ATTRIBUTE_STORE);\n\t\t\t\t\t\tconst currentComponentName = moduleHelper.getOriginalComponentName(currentRoot.tagName);\n\n\t\t\t\t\t\t// store did not change state\n\t\t\t\t\t\tif (!currentStore || !(currentStore in storeNamesSet)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// this component element does not have an\n\t\t\t\t\t\t// implementation, skipping....\n\t\t\t\t\t\tif (!(currentComponentName in components)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlastRoot = currentRoot;\n\t\t\t\t\t\tlastRootId = currentId;\n\t\t\t\t\t}\n\n\t\t\t\t\t// we don't want the same root element twice\n\t\t\t\t\tif (lastRootId in rootsSet) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\trootsSet[lastRootId] = true;\n\t\t\t\t\troots.push(lastRoot);\n\t\t\t\t});\n\t\t\t});\n\n\t\treturn roots;\n\t}\n\n\t/**\n\t * Creates a rendering context.\n\t * @param {Array?} changedStores Names of changed stores.\n\t * @returns {{\n\t *   config: Object,\n\t *   renderedIds: {},\n\t *   unboundIds: {},\n\t *   isHeadRendered: boolean,\n\t *   bindMethods: Array,\n\t *   routingContext: Object,\n\t *   components: Object,\n\t *   roots: Array.<Element>\n\t * }} The context object.\n\t * @private\n\t */\n\t_createRenderingContext(changedStores) {\n\t\tconst components = this._componentLoader.getComponentsByNames();\n\n\t\treturn {\n\t\t\tconfig: this._config,\n\t\t\trenderedIds: Object.create(null),\n\t\t\tunboundIds: Object.create(null),\n\t\t\tisHeadRendered: false,\n\t\t\tbindMethods: [],\n\t\t\troutingContext: this._currentRoutingContext,\n\t\t\tcomponents,\n\t\t\trootIds: Object.create(null),\n\t\t\troots: changedStores ? this._findRenderingRoots(changedStores) : []\n\t\t};\n\t}\n\n\t/**\n\t * Gets an ID of the element.\n\t * @param {Element} element HTML element of the component.\n\t * @returns {string} ID.\n\t */\n\t_getId(element) {\n\t\tif (element === this._window.document.documentElement) {\n\t\t\treturn SPECIAL_IDS.$$document;\n\t\t}\n\n\t\tif (element === this._window.document.head) {\n\t\t\treturn SPECIAL_IDS.$$head;\n\t\t}\n\n\t\t// if the element does not have an ID we create it\n\t\tif (!element[moduleHelper.COMPONENT_ID]) {\n\t\t\telement[moduleHelper.COMPONENT_ID] = uuid.v4();\n\t\t\t// deal with possible collisions\n\t\t\twhile (element[moduleHelper.COMPONENT_ID] in this._componentInstances) {\n\t\t\t\telement[moduleHelper.COMPONENT_ID] = uuid.v4();\n\t\t\t}\n\t\t}\n\t\treturn element[moduleHelper.COMPONENT_ID];\n\t}\n\n\t/**\n\t * Gets a cross-browser \"matches\" method for the element.\n\t * @param {Element} element HTML element.\n\t * @returns {Function} \"matches\" method.\n\t * @private\n\t */\n\t_getMatchesMethod(element) {\n\t\tconst method = (\n\t\t\telement.matches ||\n\t\t\telement.webkitMatchesSelector ||\n\t\t\telement.mozMatchesSelector ||\n\t\t\telement.oMatchesSelector ||\n\t\t\telement.msMatchesSelector ||\n\t\t\t(selector => matches(this._window, element, selector))\n\t\t);\n\n\t\treturn method.bind(element);\n\t}\n}\n\n/**\n * Converts NamedNodeMap of Attr items to the key-value object map.\n * @param {NamedNodeMap} attributes List of Element attributes.\n * @returns {Object} Map of attribute values by their names.\n */\nfunction attributesToObject(attributes) {\n\tconst result = Object.create(null);\n\tArray.prototype.forEach.call(attributes, current => {\n\t\tresult[current.name] = current.value;\n\t});\n\treturn result;\n}\n\n/**\n * Matches the specified element to the selector (fallback).\n * @param {Window} currentWindow Current browser window.\n * @param {Element} element DOM element.\n * @param {string} selector Selector for matching.\n * @returns {boolean} Does the element match.\n */\nfunction matches(currentWindow, element, selector) {\n\tconst ownerDocument = element.document || element.ownerDocument || currentWindow.document;\n\tconst matched = ownerDocument.querySelectorAll(selector);\n\treturn Array.prototype.some.call(matched, item => item === element);\n}\n\n/**\n * Creates an imitation of the original Event object but with specified currentTarget.\n * @param {Event} event Original event object.\n * @param {Function} currentTargetGetter Getter for the currentTarget.\n * @returns {Event} Wrapped event.\n */\nfunction createCustomEvent(event, currentTargetGetter) {\n\tconst catEvent = Object.create(event);\n\tconst keys = [];\n\tconst properties = {};\n\n\t/* eslint guard-for-in: 0 */\n\tfor (const key in event) {\n\t\tkeys.push(key);\n\t}\n\tkeys.forEach(key => {\n\t\tif (typeof (event[key]) === 'function') {\n\t\t\tproperties[key] = {\n\t\t\t\tget: () => event[key].bind(event)\n\t\t\t};\n\t\t\treturn;\n\t\t}\n\n\t\tproperties[key] = {\n\t\t\tget: () => event[key],\n\t\t\tset: value => {\n\t\t\t\tevent[key] = value;\n\t\t\t}\n\t\t};\n\t});\n\n\tproperties.currentTarget = {\n\t\tget: currentTargetGetter\n\t};\n\tObject.defineProperties(catEvent, properties);\n\tObject.seal(catEvent);\n\tObject.freeze(catEvent);\n\treturn catEvent;\n}\n\n/**\n * Checks if we can mutate the specified HTML tag.\n * @param {Element} element The DOM element.\n * @returns {boolean} true if element should not be mutated.\n */\nfunction isTagImmutable(element) {\n\t// these 3 kinds of tags once loaded can not be removed\n\t// otherwise it will cause style or script reloading\n\treturn element.nodeName === TAG_NAMES.SCRIPT ||\n\t\telement.nodeName === TAG_NAMES.STYLE ||\n\t\telement.nodeName === TAG_NAMES.LINK &&\n\t\telement.getAttribute('rel') === 'stylesheet';\n}\n\nmodule.exports = DocumentRenderer;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/browser/RequestRouter.js":"'use strict';\n\nconst URI = require('catberry-uri').URI;\n\nconst MOUSE_PRIMARY_KEY = 0;\nconst HREF_ATTRIBUTE_NAME = 'href';\nconst TARGET_ATTRIBUTE_NAME = 'target';\nconst A_TAG_NAME = 'A';\nconst BODY_TAG_NAME = 'BODY';\n\nclass RequestRouter {\n\n\t/**\n\t * Creates a new instance of the browser request router.\n\t * @param {ServiceLocator} locator The service locator for resolving dependencies.\n\t */\n\tconstructor(locator) {\n\n\t\t/**\n\t\t * Current event bus.\n\t\t * @type {EventEmitter}\n\t\t * @private\n\t\t */\n\t\tthis._eventBus = locator.resolve('eventBus');\n\n\t\t/**\n\t\t * Current browser window.\n\t\t * @type {Window}\n\t\t * @private\n\t\t */\n\t\tthis._window = locator.resolve('window');\n\n\t\t/**\n\t\t * Current document renderer.\n\t\t * @type {DocumentRenderer}\n\t\t * @private\n\t\t */\n\t\tthis._documentRenderer = locator.resolve('documentRenderer');\n\n\t\t/**\n\t\t * Current state provider.\n\t\t * @type {StateProvider}\n\t\t * @private\n\t\t */\n\t\tthis._stateProvider = locator.resolve('stateProvider');\n\n\t\t/**\n\t\t * Current context factory.\n\t\t * @type {ContextFactory}\n\t\t * @private\n\t\t */\n\t\tthis._contextFactory = locator.resolve('contextFactory');\n\n\t\t/**\n\t\t * True if current browser supports history API.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._isHistorySupported = this._window.history &&\n\t\t\tthis._window.history.pushState instanceof Function;\n\n\t\t// add event handlers\n\t\tthis._wrapDocument();\n\n\t\t/**\n\t\t * Current location.\n\t\t * @type {URI}\n\t\t * @private\n\t\t */\n\t\tthis._location = new URI(this._window.location.toString());\n\n\t\t// set initial state from current URI\n\t\t/**\n\t\t * Current state.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._state = this._stateProvider.getStateByUri(this._location);\n\n\t\t/**\n\t\t * Current initialization flag.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._isStateInitialized = false;\n\n\t\t/**\n\t\t * Current referrer.\n\t\t * @type {URI}\n\t\t * @private\n\t\t */\n\t\tthis._referrer = '';\n\n\t\tthis._changeState(this._state)\n\t\t\t.catch(reason => this._handleError(reason));\n\t}\n\n\t/**\n\t * Sets an application state for the specified URI.\n\t * @param {string} locationString URI to go.\n\t * @param {boolean?} isHistoryAction If it's a back or forward history action.\n\t * @returns {Promise} Promise for nothing.\n\t */\n\t/* eslint complexity: 0 */\n\tgo(locationString, isHistoryAction) {\n\n\t\t// we must immediately change the URL, therefore this method is synchronous\n\t\ttry {\n\t\t\tconst newLocation = (new URI(locationString)).resolveRelative(this._location);\n\t\t\tconst newLocationString = newLocation.toString();\n\n\t\t\tconst currentAuthority = this._location.authority ?\n\t\t\t\tthis._location.authority.toString() : null;\n\t\t\tconst newAuthority = newLocation.authority ?\n\t\t\t\tnewLocation.authority.toString() : null;\n\n\t\t\t// we must check if history API is supported or if this is an external link\n\t\t\t// before mapping URI to internal application state\n\t\t\tif (!this._isHistorySupported ||\n\t\t\t\tnewLocation.scheme !== this._location.scheme ||\n\t\t\t\tnewAuthority !== currentAuthority) {\n\t\t\t\tthis._window.location.assign(newLocationString);\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\t// if only URI fragment is changed we don't need to update\n\t\t\t// the whole state of the app\n\t\t\tconst newQuery = newLocation.query ?\n\t\t\t\tnewLocation.query.toString() : null;\n\t\t\tconst currentQuery = this._location.query ?\n\t\t\t\tthis._location.query.toString() : null;\n\n\t\t\tif (newLocation.path === this._location.path &&\tnewQuery === currentQuery) {\n\t\t\t\tthis._location = newLocation;\n\t\t\t\tthis._window.location.hash = this._location.fragment || '';\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\tconst state = this._stateProvider.getStateByUri(newLocation);\n\t\t\tif (!state) {\n\t\t\t\tthis._window.location.assign(newLocationString);\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\tthis._state = state;\n\t\t\tthis._referrer = this._location;\n\t\t\tthis._location = newLocation;\n\n\t\t\tif (!isHistoryAction) {\n\t\t\t\tthis._window.history.pushState(state, '', newLocationString);\n\t\t\t}\n\n\t\t\treturn this._changeState(state);\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\t/**\n\t * Changes the current application state with the new location.\n\t * @param {Object} state New state.\n\t * @returns {Promise} Promise for nothing.\n\t * @private\n\t */\n\t_changeState(state) {\n\t\treturn Promise.resolve()\n\t\t\t.then(() => {\n\t\t\t\t// for \"not found\" state\n\t\t\t\tif (state === null) {\n\t\t\t\t\tthis._window.location.reload();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst routingContext = this._contextFactory.create({\n\t\t\t\t\treferrer: this._referrer || this._window.document.referrer,\n\t\t\t\t\tlocation: this._location,\n\t\t\t\t\tuserAgent: this._window.navigator.userAgent\n\t\t\t\t});\n\n\t\t\t\tif (!this._isStateInitialized) {\n\t\t\t\t\tthis._isStateInitialized = true;\n\t\t\t\t\treturn this._documentRenderer.initWithState(state, routingContext);\n\t\t\t\t}\n\n\t\t\t\treturn this._documentRenderer.render(state, routingContext);\n\t\t\t});\n\t}\n\n\t/**\n\t * Wraps the document with required events to route requests.\n\t * @private\n\t */\n\t_wrapDocument() {\n\t\tif (!this._isHistorySupported) {\n\t\t\treturn;\n\t\t}\n\n\t\t// because now location was not change yet and\n\t\t// different browsers handle `popstate` differently\n\t\t// we need to do route in next iteration of event loop\n\t\tthis._window.addEventListener('popstate', () =>\n\t\t\tPromise.resolve()\n\t\t\t\t.then(() => this.go(this._window.location.toString(), true))\n\t\t\t\t.catch(reason => this._handleError(reason))\n\t\t);\n\n\t\tthis._window.document.body.addEventListener('click', event => {\n\t\t\tif (event.defaultPrevented) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (event.target.tagName === A_TAG_NAME) {\n\t\t\t\tthis._linkClickHandler(event, event.target);\n\t\t\t} else {\n\t\t\t\tconst link = closestLink(event.target);\n\t\t\t\tif (!link) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._linkClickHandler(event, link);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Handles a link click on the page.\n\t * @param {Event} event Event-related object.\n\t * @param {Element} element Link element.\n\t * @private\n\t */\n\t_linkClickHandler(event, element) {\n\t\tconst targetAttribute = element.getAttribute(TARGET_ATTRIBUTE_NAME);\n\t\tif (targetAttribute) {\n\t\t\treturn;\n\t\t}\n\n\t\t// if middle mouse button was clicked\n\t\tif (event.button !== MOUSE_PRIMARY_KEY ||\n\t\t\tevent.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst locationString = element.getAttribute(HREF_ATTRIBUTE_NAME);\n\t\tif (!locationString) {\n\t\t\treturn;\n\t\t}\n\n\t\tevent.preventDefault();\n\t\tthis.go(locationString)\n\t\t\t.catch(reason => this._handleError(reason));\n\t}\n\n\t/**\n\t * Handles all errors.\n\t * @param {Error} error Error to handle.\n\t * @private\n\t */\n\t_handleError(error) {\n\t\tthis._eventBus.emit('error', error);\n\t}\n}\n\n/**\n * Finds the closest ascending \"A\" element node.\n * @param {Node} element DOM element.\n * @returns {Node|null} The closest \"A\" element or null.\n */\nfunction closestLink(element) {\n\twhile (element && element.nodeName !== A_TAG_NAME &&\n\t\telement.nodeName !== BODY_TAG_NAME) {\n\t\telement = element.parentNode;\n\t}\n\treturn element && element.nodeName === A_TAG_NAME ? element : null;\n}\n\nmodule.exports = RequestRouter;\n","/home/travis/build/npmtest/node-npmtest-catberry/node_modules/catberry/lib/appDefinitions.js":"/**\n * This file is a template and it is used only for some string replaces\n * by BrowserBundleBuilder module. It does not work by itself.\n */\n\n'use strict';\n\nconst stores = [\n\n/** __stores **/\n\n];\n\nconst components = [\n\n/** __components **/\n\n];\n\nconst routeDefinitions = '__routeDefinitions' || [];\nconst routeDescriptors = '__routes' || [];\n\nmodule.exports = {\n\tstores,\n\tcomponents,\n\trouteDefinitions,\n\trouteDescriptors\n};\n"}